<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LiJingBiao</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 21 Apr 2021 16:42:44 +0800</pubDate>
    <lastBuildDate>Wed, 21 Apr 2021 16:42:44 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>iOS 多线程：GCD详尽总结</title>
        <description>&lt;p&gt;iOS 多线程：『GCD』详尽总结&lt;/p&gt;

&lt;p&gt;本文用来介绍 iOS 多线程中 GCD 的相关知识以及使用方法。这大概是史上最详细、清晰的关于 &lt;strong&gt;GCD 的详细讲解 + 总结&lt;/strong&gt; 的文章了。通过本文，您将了解到：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. GCD 简介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. GCD 任务和队列&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. GCD 的使用步骤&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. GCD 的基本使用&lt;/strong&gt;（六种组合不同区别，队列嵌套情况区别，相互关系形象理解）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. GCD 线程间的通信&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. GCD 的其他方法&lt;/strong&gt;（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次）：dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore）&lt;/p&gt;

&lt;p&gt;文中 Demo 我已放在了 Github 上，Demo 链接：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fbujige%2FYSC-GCD-demo&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;一gcd-简介&quot;&gt;一、GCD 简介&lt;/h1&gt;

&lt;h2 id=&quot;什么是-gcd-我们先来看看百度百科的解释简单了解下相关概念&quot;&gt;什么是 &lt;strong&gt;GCD&lt;/strong&gt; ？我们先来看看百度百科的解释简单了解下相关概念。&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;引自 &lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fbaike.baidu.com%2Fitem%2FGCD&quot;&gt;百度百科&lt;/a&gt;
&lt;strong&gt;Grand Central Dispatch（GCD）&lt;/strong&gt; 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;那为什么我们要使用-gcd-呢&quot;&gt;那为什么我们要使用 GCD 呢?&lt;/h2&gt;

&lt;p&gt;因为使用 GCD 有很多好处啊，具体如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GCD 可用于多核的并行运算；&lt;/li&gt;
  &lt;li&gt;GCD 会自动利用更多的 CPU 内核（比如双核、四核）；&lt;/li&gt;
  &lt;li&gt;GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）；&lt;/li&gt;
  &lt;li&gt;程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GCD 拥有以上这么多的好处，而且在多线程中处于举足轻重的地位。那么我们就很有必要系统地学习一下 GCD 的使用方法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;二gcd-任务和队列&quot;&gt;二、GCD 任务和队列&lt;/h1&gt;

&lt;p&gt;学习 GCD 之前，先来了解 GCD 中两个核心概念：&lt;strong&gt;『任务』&lt;/strong&gt; 和 &lt;strong&gt;『队列』&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt;：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：&lt;strong&gt;『同步执行』&lt;/strong&gt; 和 &lt;strong&gt;『异步执行』&lt;/strong&gt;。两者的主要区别是：&lt;strong&gt;是否等待队列的任务执行结束，以及是否具备开启新线程的能力。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;同步执行（sync）&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。&lt;/li&gt;
      &lt;li&gt;只能在当前线程中执行任务，不具备开启新线程的能力。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异步执行（async）&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。&lt;/li&gt;
      &lt;li&gt;可以在新的线程中执行任务，具备开启新线程的能力。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个简单例子：你要打电话给小明和小白。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;『同步执行』&lt;/strong&gt; 就是：你打电话给小明的时候，不能同时打给小白。只有等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;『异步执行』&lt;/strong&gt; 就是：你打电话给小明的时候，不用等着和小明通话结束（不用等待任务执行结束），还能同时给小白打电话。而且除了当前电话，你还可以使用其他一个或多个电话（具备开启新线程的能力）。&lt;/p&gt;

&lt;p&gt;注意：&lt;strong&gt;异步执行（async）&lt;/strong&gt;虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队列（Dispatch Queue）&lt;/strong&gt;：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/1877784-01267bd211719167.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 GCD 中有两种队列：&lt;strong&gt;『串行队列』&lt;/strong&gt; 和 &lt;strong&gt;『并发队列』&lt;/strong&gt;。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：&lt;strong&gt;执行顺序不同，以及开启线程数不同。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;串行队列（Serial Dispatch Queue）&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;并发队列（Concurrent Dispatch Queue）&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：&lt;strong&gt;并发队列&lt;/strong&gt; 的并发功能只有在异步（dispatch_async）方法下才有效。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者具体区别如下两图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/1877784-4faca27116209f35.webp&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/images/posts/iOS/1877784-97f3931d1b187b11.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;三gcd-的使用步骤&quot;&gt;三、GCD 的使用步骤&lt;/h1&gt;

&lt;p&gt;GCD 的使用步骤其实很简单，只有两步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个队列（串行队列或并发队列）；&lt;/li&gt;
  &lt;li&gt;将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下边来看看队列的创建方法 / 获取方法，以及任务的创建方法。&lt;/p&gt;

&lt;h2 id=&quot;1-队列的创建方法--获取方法&quot;&gt;1. 队列的创建方法 / 获取方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt;方法来创建队列。该方法需要传入两个参数：
    &lt;ul&gt;
      &lt;li&gt;第一个参数表示队列的唯一标识符，用于 DEBUG，可为空。队列的名称推荐使用应用程序 ID 这种逆序全程域名。&lt;/li&gt;
      &lt;li&gt;第二个参数用来识别是串行队列还是并发队列。&lt;code class=&quot;highlighter-rouge&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/code&gt;表示串行队列，&lt;code class=&quot;highlighter-rouge&quot;&gt;DISPATCH_QUEUE_CONCURRENT&lt;/code&gt;表示并发队列。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 串行队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);
// 并发队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;对于串行队列，GCD 默认提供了：&lt;strong&gt;『主队列（Main Dispatch Queue）』&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;所有放在主队列中的任务，都会放到主线程中执行。&lt;/li&gt;
      &lt;li&gt;可使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_get_main_queue()&lt;/code&gt;方法获得主队列。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;注意：&lt;strong&gt;主队列其实并不特殊。&lt;/strong&gt; 主队列的实质上就是一个普通的串行队列，只是因为默认情况下，当前代码是放在主队列中的，然后主队列中的代码，有都会放到主线程中去执行，所以才造成了主队列特殊的现象。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 主队列的获取方法
dispatch_queue_t queue = dispatch_get_main_queue();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;对于并发队列，GCD 默认提供了 &lt;strong&gt;『全局并发队列（Global Dispatch Queue）』&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;可以使用 dispatch_get_global_queue方法来获取全局并发队列。需要传入两个参数。第一个参数表示队列优先级，一般用 DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用 0即可。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 全局并发队列的获取方法
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-任务的创建方法&quot;&gt;2. 任务的创建方法&lt;/h2&gt;

&lt;p&gt;GCD 提供了同步执行任务的创建方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt; 和异步执行任务创建方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 同步执行任务创建方法 
dispatch_sync(queue, ^{ 
  // 这里放同步执行任务代码 
  }); 
// 异步执行任务创建方法 
dispatch_async(queue, ^{ 
  // 这里放异步执行任务代码 
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列 / 并发队列），两种任务执行方式（同步执行 / 异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;同步执行 + 并发队列&lt;/li&gt;
  &lt;li&gt;异步执行 + 并发队列&lt;/li&gt;
  &lt;li&gt;同步执行 + 串行队列&lt;/li&gt;
  &lt;li&gt;异步执行 + 串行队列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上，刚才还说了两种默认队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是当前代码默认放在主队列中，所以主队列很有必要专门来研究一下，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;同步执行 + 主队列&lt;/li&gt;
  &lt;li&gt;异步执行 + 主队列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;那么这几种不同组合方式各有什么区别呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里我们先上结论，后面再来详细讲解。你可以直接查看 &lt;strong&gt;3 任务和队列不同组合方式的区别&lt;/strong&gt; 中的表格结果，然后跳过 &lt;strong&gt;4. GCD的基本使用&lt;/strong&gt; 继续往后看。&lt;/p&gt;

&lt;h2 id=&quot;3-任务和队列不同组合方式的区别&quot;&gt;3. 任务和队列不同组合方式的区别&lt;/h2&gt;

&lt;p&gt;我们先来考虑最基本的使用，也就是当前线程为 &lt;strong&gt;『主线程』&lt;/strong&gt; 的环境下，&lt;strong&gt;『不同队列』+『不同任务』&lt;/strong&gt; 简单组合使用的不同区别。暂时不考虑 &lt;strong&gt;『队列中嵌套队列』&lt;/strong&gt; 的这种复杂情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;『主线程』&lt;/strong&gt;中，&lt;strong&gt;『不同队列』&lt;/strong&gt;+&lt;strong&gt;『不同任务』&lt;/strong&gt;简单组合的区别：&lt;/p&gt;

&lt;table&gt;&lt;tr&gt;&lt;th&gt;区别&lt;/th&gt;&lt;th&gt;并发队列&lt;/th&gt;&lt;th&gt;串行队列&lt;/th&gt;&lt;th&gt;主队列&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;同步（sync）&lt;/td&gt;&lt;td&gt;没有开启新线程，串行执行任务&lt;/td&gt;&lt;td&gt;没有开启新线程，串行执行任务&lt;/td&gt;&lt;td&gt;死锁卡住不执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异步（async）&lt;/td&gt;&lt;td&gt;有开启新线程，并发执行任务&lt;/td&gt;&lt;td&gt;有开启新线程（1条），串行执行任务&lt;/td&gt;&lt;td&gt;没有开启新线程，串行执行任务&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：从上边可看出： &lt;strong&gt;『主线程』&lt;/strong&gt; 中调用 &lt;strong&gt;『主队列』+『同步执行』&lt;/strong&gt; 会导致死锁问题。这是因为 &lt;strong&gt;主队列中追加的同步任务&lt;/strong&gt; 和 &lt;strong&gt;主线程本身的任务&lt;/strong&gt; 两者之间相互等待，阻塞了 &lt;strong&gt;『主队列』&lt;/strong&gt;，最终造成了主队列所在的线程（主线程）死锁问题。而如果我们在 &lt;strong&gt;『其他线程』&lt;/strong&gt; 调用 &lt;strong&gt;『主队列』+『同步执行』&lt;/strong&gt;，则不会阻塞 &lt;strong&gt;『主队列』&lt;/strong&gt;，自然也不会造成死锁问题。最终的结果是：&lt;strong&gt;不会开启新线程，串行执行任务&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;4-队列嵌套情况下不同组合方式区别&quot;&gt;4. 队列嵌套情况下，不同组合方式区别&lt;/h2&gt;

&lt;p&gt;除了上边提到的『主线程』中调用『主队列』+『同步执行』会导致死锁问题。实际在使用『串行队列』的时候，也可能出现阻塞『串行队列』所在线程的情况发生，从而造成死锁问题。这种情况多见于同一个串行队列的嵌套使用。&lt;/p&gt;

&lt;p&gt;比如下面代码这样：在『异步执行』+『串行队列』的任务中，又嵌套了『当前的串行队列』，然后进行『同步执行』。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL); 
  dispatch_async(queue, ^{ // 异步执行 + 串行队列 
    dispatch_sync(queue, ^{ // 同步执行 + 当前串行队列 
      // 追加任务 1 
      [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 
      NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 
      }); 
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;执行上面的代码会导致 &lt;strong&gt;串行队列中追加的任务&lt;/strong&gt; 和 &lt;strong&gt;串行队列中原有的任务&lt;/strong&gt; 两者之间相互等待，阻塞了『串行队列』，最终造成了串行队列所在的线程（子线程）死锁问题。
主队列造成死锁也是基于这个原因，所以，这也进一步说明了主队列其实并不特殊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于 『队列中嵌套队列』这种复杂情况，这里也简单做一个总结。不过这里只考虑同一个队列的嵌套情况，关于多个队列的相互嵌套情况还请自行研究，或者等我最新的文章发布。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;『不同队列』+『不同任务』&lt;/strong&gt; 组合，以及 &lt;strong&gt;『队列中嵌套队列』&lt;/strong&gt; 使用的区别：&lt;/p&gt;

&lt;table&gt;&lt;tr&gt;&lt;th&gt;区别&lt;/th&gt;&lt;th&gt;『异步执行+并发队列』嵌套『同一个并发队列』&lt;/th&gt;&lt;th&gt;『同步执行+并发队列』嵌套『同一个并发队列』&lt;/th&gt;&lt;th&gt;『异步执行+串行队列』嵌套『同一个串行队列』&lt;/th&gt;&lt;th&gt;『同步执行+串行队列』嵌套『同一个串行队列』&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;同步（sync）&lt;/td&gt;&lt;td&gt;没有开启新的线程，串行执行任务&lt;/td&gt;&lt;td&gt;没有开启新线程，串行执行任务&lt;/td&gt;&lt;td&gt;死锁卡住不执行&lt;/td&gt;&lt;td&gt;死锁卡住不执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;异步（async）&lt;/td&gt;&lt;td&gt;有开启新线程，并发执行任务&lt;/td&gt;&lt;td&gt;有开启新线程，并发执行任务&lt;/td&gt;&lt;td&gt;有开启新线程（1 条），串行执行任务&lt;/td&gt;&lt;td&gt;有开启新线程（1 条），串行执行任务&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;好了，关于『不同队列』+『不同任务』 组合不同区别总结就到这里。&lt;/p&gt;

&lt;h2 id=&quot;5-关于不同队列和不同任务的形象理解&quot;&gt;5. 关于不同队列和不同任务的形象理解&lt;/h2&gt;

&lt;p&gt;因为前一段时间看到了有朋友留言说对 &lt;code class=&quot;highlighter-rouge&quot;&gt;异步执行&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;并发队列&lt;/code&gt; 中创建线程能力有所不理解，我觉得这个问题的确很容易造成困惑，所以很值得拿来专门分析一下。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;他的问题：
在 异步 + 并发 中的解释：
异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）
以及 同步 + 并发 中的解释：
（虽然并发队列可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务不具备开启新线程的能力）
这个地方看起来有点疑惑，你两个地方分别提到：异步执行开启新线程，并发队列也可以开启新线程，想请教下，你的意思是只有任务才拥有创建新线程的能力，而队列只有开启线程的能力，并不能创建线程 ？这二者是这样的关联吗？&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;关于这个问题，我想做一个很形象的类比，来帮助大家对 &lt;strong&gt;队列&lt;/strong&gt;、&lt;strong&gt;任务&lt;/strong&gt; 以及 &lt;strong&gt;线程&lt;/strong&gt; 之间关系的理解。&lt;/p&gt;

&lt;p&gt;假设现在有 5 个人要穿过一道门禁，这道门禁总共有 10 个入口，管理员可以决定同一时间打开几个入口，可以决定同一时间让一个人单独通过还是多个人一起通过。不过默认情况下，管理员只开启一个入口，且一个通道一次只能通过一个人。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个故事里，人好比是 &lt;strong&gt;任务&lt;/strong&gt;，管理员好比是 &lt;strong&gt;系统&lt;/strong&gt;，入口则代表 &lt;strong&gt;线程&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;5 个人表示有 5 个任务，10 个入口代表 10 条线程。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;串行队列&lt;/strong&gt;好比是 5 个人排成一支长队。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;并发队列&lt;/strong&gt;好比是 5 个人排成多支队伍，比如 2 队，或者 3 队。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;同步任务&lt;/strong&gt;好比是管理员只开启了一个入口（当前线程）。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;异步任务&lt;/strong&gt;好比是管理员同时开启了多个入口（当前线程 + 新开的线程）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;『异步执行 + 并发队列』&lt;/strong&gt;可以理解为：现在管理员开启了多个入口（比如 3 个入口），5 个人排成了多支队伍（比如 3 支队伍），这样这 5 个人就可以 3 个人同时一起穿过门禁了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;『同步执行 + 并发队列』&lt;/strong&gt;可以理解为：现在管理员只开启了 1 个入口，5 个人排成了多支队伍。虽然这 5 个人排成了多支队伍，但是只开了 1 个入口啊，这 5 个人虽然都想快点过去，但是 1 个入口一次只能过 1 个人，所以大家就只好一个接一个走过去了，表现的结果就是：顺次通过入口。&lt;/li&gt;
  &lt;li&gt;换成 GCD 里的语言就是说：
    &lt;ul&gt;
      &lt;li&gt;『异步执行 + 并发队列』就是：系统开启了多个线程（主线程+其他子线程），任务可以多个同时运行。&lt;/li&gt;
      &lt;li&gt;『同步执行 + 并发队列』就是：系统只默认开启了一个主线程，没有开启子线程，虽然任务处于并发队列中，但也只能一个接一个执行了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下边我们来研究一下上边提到的六种简单组合方式的使用方法。&lt;/p&gt;

&lt;h1 id=&quot;四gcd-的基本使用&quot;&gt;四、GCD 的基本使用&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;先来讲讲并发队列的两种执行方式。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-同步执行--并发队列&quot;&gt;1. 同步执行 + 并发队列&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 同步执行 + 并发队列
 * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)syncConcurrent {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;syncConcurrent---begin&quot;);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    NSLog(@&quot;syncConcurrent---end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:32:53.542816+0800 YSC-GCD-demo[16332:4171500] currentThread---{number = 1, name = main}
   
 2019-08-08 14:32:53.542964+0800 YSC-GCD-demo[16332:4171500] syncConcurrent---begin
   
 2019-08-08 14:32:55.544329+0800 YSC-GCD-demo[16332:4171500] 1---{number = 1, name = main}
   
 2019-08-08 14:32:57.545779+0800 YSC-GCD-demo[16332:4171500] 2---{number = 1, name = main}
   
 2019-08-08 14:32:59.547154+0800 YSC-GCD-demo[16332:4171500] 3---{number = 1, name = main}
   
 2019-08-08 14:32:59.547365+0800 YSC-GCD-demo[16332:4171500] syncConcurrent---end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从 &lt;code class=&quot;highlighter-rouge&quot;&gt;同步执行 + 并发队列&lt;/code&gt; 中可看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（&lt;code class=&quot;highlighter-rouge&quot;&gt;同步执行&lt;/code&gt;不具备开启新线程的能力）。&lt;/li&gt;
  &lt;li&gt;所有任务都在打印的 &lt;code class=&quot;highlighter-rouge&quot;&gt;syncConcurrent---begin&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;syncConcurrent---end&lt;/code&gt;之间执行的（&lt;code class=&quot;highlighter-rouge&quot;&gt;同步任务&lt;/code&gt;需要等待队列的任务执行结束）。&lt;/li&gt;
  &lt;li&gt;任务按顺序执行的。按顺序执行的原因：虽然 &lt;code class=&quot;highlighter-rouge&quot;&gt;并发队列&lt;/code&gt;可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（&lt;code class=&quot;highlighter-rouge&quot;&gt;同步任务&lt;/code&gt;不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（&lt;code class=&quot;highlighter-rouge&quot;&gt;同步任务&lt;/code&gt;需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-异步执行--并发队列&quot;&gt;2. 异步执行 + 并发队列&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可以开启多个线程，任务交替（同时）执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 异步执行 + 并发队列
 * 特点：可以开启多个线程，任务交替（同时）执行。
 */
- (void)asyncConcurrent {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;asyncConcurrent---begin&quot;);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    NSLog(@&quot;asyncConcurrent---end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:36:37.747966+0800 YSC-GCD-demo[17232:4187114] currentThread---{number = 1, name = main}
   
 2019-08-08 14:36:37.748150+0800 YSC-GCD-demo[17232:4187114] asyncConcurrent---begin
   
 2019-08-08 14:36:37.748279+0800 YSC-GCD-demo[17232:4187114] asyncConcurrent---end
   
 2019-08-08 14:36:39.752523+0800 YSC-GCD-demo[17232:4187204] 2---{number = 3, name = (null)}
   
 2019-08-08 14:36:39.752527+0800 YSC-GCD-demo[17232:4187202] 3---{number = 5, name = (null)}
   
 2019-08-08 14:36:39.752527+0800 YSC-GCD-demo[17232:4187203] 1---{number = 4, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;异步执行&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;并发队列&lt;/code&gt; 中可以看出：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了当前线程（主线程），系统又开启了 3 个线程，并且任务是交替/同时执行的。（异步执行具备开启新线程的能力。且 并发队列可开启多个线程，同时执行多个任务）。&lt;/li&gt;
  &lt;li&gt;所有任务是在打印的 syncConcurrent—begin和 syncConcurrent—end之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，可以继续执行任务）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;接下来再来讲讲串行队列的两种执行方式。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-同步执行--串行队列&quot;&gt;3. 同步执行 + 串行队列&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 同步执行 + 串行队列
 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)syncSerial {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;syncSerial---begin&quot;);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);
    
    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    NSLog(@&quot;syncSerial---end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:39:31.366815+0800 YSC-GCD-demo[17285:4197645] currentThread---{number = 1, name = main}
   
 2019-08-08 14:39:31.366952+0800 YSC-GCD-demo[17285:4197645] syncSerial---begin
   
 2019-08-08 14:39:33.368256+0800 YSC-GCD-demo[17285:4197645] 1---{number = 1, name = main}
   
 2019-08-08 14:39:35.369661+0800 YSC-GCD-demo[17285:4197645] 2---{number = 1, name = main}
   
 2019-08-08 14:39:37.370991+0800 YSC-GCD-demo[17285:4197645] 3---{number = 1, name = main}
   
 2019-08-08 14:39:37.371192+0800 YSC-GCD-demo[17285:4197645] syncSerial---end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 同步执行 + 串行队列 可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行不具备开启新线程的能力）。&lt;/li&gt;
  &lt;li&gt;所有任务都在打印的 syncConcurrent—begin和 syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。&lt;/li&gt;
  &lt;li&gt;任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-异步执行--串行队列&quot;&gt;4. 异步执行 + 串行队列&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 同步执行 + 串行队列
 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)syncSerial {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;syncSerial---begin&quot;);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);
    
    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    NSLog(@&quot;syncSerial---end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:40:53.944502+0800 YSC-GCD-demo[17313:4203018] currentThread---{number = 1, name = main}
   
 2019-08-08 14:40:53.944615+0800 YSC-GCD-demo[17313:4203018] asyncSerial---begin
   
 2019-08-08 14:40:53.944710+0800 YSC-GCD-demo[17313:4203018] asyncSerial---end
   
 2019-08-08 14:40:55.947709+0800 YSC-GCD-demo[17313:4203079] 1---{number = 3, name = (null)}
   
 2019-08-08 14:40:57.952453+0800 YSC-GCD-demo[17313:4203079] 2---{number = 3, name = (null)}
   
 2019-08-08 14:40:59.952943+0800 YSC-GCD-demo[17313:4203079] 3---{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 异步执行 + 串行队列 可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。&lt;/li&gt;
  &lt;li&gt;所有任务是在打印的 syncConcurrent—begin和 syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。&lt;/li&gt;
  &lt;li&gt;任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下边讲讲刚才我们提到过的：&lt;strong&gt;主队列&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主队列：GCD 默认提供的 &lt;strong&gt;串行队列&lt;/strong&gt;。
    &lt;ul&gt;
      &lt;li&gt;默认情况下，平常所写代码是直接放在主队列中的。&lt;/li&gt;
      &lt;li&gt;所有放在主队列中的任务，都会放到主线程中执行。&lt;/li&gt;
      &lt;li&gt;可使用 dispatch_get_main_queue()获得主队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;我们再来看看主队列的两种组合方式。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-同步执行--主队列&quot;&gt;5. 同步执行 + 主队列&lt;/h2&gt;

&lt;p&gt;同步执行 + 主队列 在不同线程中调用结果也是不一样，在主线程中调用会发生死锁问题，而在其他线程中调用则不会。&lt;/p&gt;

&lt;h3 id=&quot;-在主线程中调用-同步执行--主队列&quot;&gt;㈠ 在主线程中调用 『同步执行 + 主队列』&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;互相等待卡住不可行&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 同步执行 + 主队列
 * 特点(主线程调用)：互等卡主不执行。
 * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)syncMain {
    
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;syncMain---begin&quot;);
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    NSLog(@&quot;syncMain---end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:43:58.062376+0800 YSC-GCD-demo[17371:4213562] currentThread---{number = 1, name = main}
   
 2019-08-08 14:43:58.062518+0800 YSC-GCD-demo[17371:4213562] syncMain---begin
   
 (lldb)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在主线程中使用 同步执行 + 主队列 可以惊奇的发现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;追加到主线程的任务 1、任务 2、任务 3 都不再执行了，而且 syncMain—end也没有打印，在 XCode 9 及以上版本上还会直接报崩溃。这是为什么呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是因为我们在主线程中执行 syncMain 方法，相当于把 syncMain 任务放到了主线程的队列中。而 同步执行 会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把 任务 1 追加到主队列中，任务 1 就在等待主线程处理完 syncMain 任务。而syncMain 任务需要等待 任务 1 执行完毕，才能接着执行。&lt;/p&gt;

&lt;p&gt;那么，现在的情况就是 syncMain 任务和 任务 1 都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且 syncMain—end 也没有打印。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要是如果不在主线程中调用，而在其他线程中调用会如何呢？&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;-在其他线程中调用同步执行--主队列&quot;&gt;㈡ 在其他线程中调用『同步执行 + 主队列』&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;不会开启新线程，执行完一个任务，再执行下一个任务&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行 selector 任务
[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:51:38.137978+0800 YSC-GCD-demo[17482:4237818] currentThread---{number = 3, name = (null)}
   
 2019-08-08 14:51:38.138159+0800 YSC-GCD-demo[17482:4237818] syncMain---begin
   
 2019-08-08 14:51:40.149065+0800 YSC-GCD-demo[17482:4237594] 1---{number = 1, name = main}
   
 2019-08-08 14:51:42.151104+0800 YSC-GCD-demo[17482:4237594] 2---{number = 1, name = main}
   
 2019-08-08 14:51:44.152583+0800 YSC-GCD-demo[17482:4237594] 3---{number = 1, name = main}
   
 2019-08-08 14:51:44.152767+0800 YSC-GCD-demo[17482:4237818] syncMain---end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在其他线程中使用 同步执行 + 主队列 可看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。&lt;/li&gt;
  &lt;li&gt;所有任务都在打印的 syncConcurrent—begin和 syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。&lt;/li&gt;
  &lt;li&gt;任务是按顺序执行的（主队列是 串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么现在就不会卡住了呢？&lt;/p&gt;

&lt;p&gt;因为syncMain 任务 放到了其他线程里，而 任务 1、任务 2、任务3 都在追加到主队列中，这三个任务都会在主线程中执行。syncMain 任务 在其他线程中执行到追加 任务 1 到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的 任务1，等 任务1 执行完毕，再接着执行 任务 2、任务 3。所以这里不会卡住线程，也就不会造成死锁问题。&lt;/p&gt;

&lt;h2 id=&quot;6-异步执行--主队列&quot;&gt;6. 异步执行 + 主队列&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;只在主线程中执行任务，执行完一个任务，再执行下一个任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 异步执行 + 主队列
 * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务
 */
- (void)asyncMain {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;asyncMain---begin&quot;);
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    NSLog(@&quot;asyncMain---end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:53:27.023091+0800 YSC-GCD-demo[17521:4243690] currentThread---{number = 1, name = main}
   
 2019-08-08 14:53:27.023247+0800 YSC-GCD-demo[17521:4243690] asyncMain---begin
   
 2019-08-08 14:53:27.023399+0800 YSC-GCD-demo[17521:4243690] asyncMain---end
   
 2019-08-08 14:53:29.035565+0800 YSC-GCD-demo[17521:4243690] 1---{number = 1, name = main}
   
 2019-08-08 14:53:31.036565+0800 YSC-GCD-demo[17521:4243690] 2---{number = 1, name = main}
   
 2019-08-08 14:53:33.037092+0800 YSC-GCD-demo[17521:4243690] 3---{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 异步执行 + 主队列 可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然 异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。&lt;/li&gt;
  &lt;li&gt;所有任务是在打印的 syncConcurrent—begin和 syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。&lt;/li&gt;
  &lt;li&gt;任务是按顺序执行的（因为主队列是 串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;弄懂了难理解、绕来绕去的&lt;strong&gt;『不同队列』+『不同任务』&lt;/strong&gt;使用区别之后，我们来学习一个简单的东西：&lt;strong&gt;5. GCD 线程间的通信&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;五gcd-线程间的通信&quot;&gt;五、GCD 线程间的通信&lt;/h1&gt;

&lt;p&gt;在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程间通信
 */
- (void)communication {
    // 获取全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    // 获取主队列
    dispatch_queue_t mainQueue = dispatch_get_main_queue();
    
    dispatch_async(queue, ^{
        // 异步追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        
        // 回到主线程
        dispatch_async(mainQueue, ^{
            // 追加在主线程中执行的任务
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:56:22.973318+0800 YSC-GCD-demo[17573:4253201] 1---{number = 3, name = (null)}
   
 2019-08-08 14:56:24.973902+0800 YSC-GCD-demo[17573:4253108] 2---{number = 1, name = main}

  - 可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;六gcd-的其他方法&quot;&gt;六、GCD 的其他方法&lt;/h1&gt;

&lt;h2 id=&quot;1-gcd-栅栏方法dispatch_barrier_async&quot;&gt;1. GCD 栅栏方法：dispatch_barrier_async&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;dispatch_barrier_async方法会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 dispatch_barrier_async方法追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/1877784-4d6d77fafd3ad007.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 栅栏方法 dispatch_barrier_async
 */
- (void)barrier {
    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_barrier_async(queue, ^{
        // 追加任务 barrier
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;barrier---%@&quot;,[NSThread currentThread]);// 打印当前线程
    });
    
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 4
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;4---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 14:59:02.540868+0800 YSC-GCD-demo[17648:4262933] 1---{number = 3, name = (null)}
   
 2019-08-08 14:59:02.540868+0800 YSC-GCD-demo[17648:4262932] 2---{number = 4, name = (null)}
   
 2019-08-08 14:59:04.542346+0800 YSC-GCD-demo[17648:4262933] barrier---{number = 3, name = (null)}
   
 2019-08-08 14:59:06.542772+0800 YSC-GCD-demo[17648:4262932] 4---{number = 4, name = (null)}
   
 2019-08-08 14:59:06.542773+0800 YSC-GCD-demo[17648:4262933] 3---{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 dispatch_barrier_async 执行结果中可以看出：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-gcd-延时执行方法dispatch_after&quot;&gt;2. GCD 延时执行方法：dispatch_after&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;我们经常会遇到这样的需求：在指定时间（例如 3 秒）之后执行某个任务。可以用 GCD 的dispatch_after 方法来实现。&lt;/p&gt;

&lt;p&gt;需要注意的是：dispatch_after 方法并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after 方法是很有效的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 延时执行方法 dispatch_after
 */
- (void)after {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;asyncMain---begin&quot;);
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        // 2.0 秒后异步追加任务代码到主队列，并开始执行
        NSLog(@&quot;after---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:01:33.569710+0800 YSC-GCD-demo[17702:4272430] currentThread---{number = 1, name = main}
   
 2019-08-08 15:01:33.569838+0800 YSC-GCD-demo[17702:4272430] asyncMain---begin
   
 2019-08-08 15:01:35.570146+0800 YSC-GCD-demo[17702:4272430] after---{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看出：在打印 &lt;code class=&quot;highlighter-rouge&quot;&gt;asyncMain---begin&lt;/code&gt; 之后大约 2.0 秒的时间，打印了 &lt;code class=&quot;highlighter-rouge&quot;&gt;after---{number = 1, name = main}&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-gcd-一次性代码只执行一次dispatch_once&quot;&gt;3. GCD 一次性代码（只执行一次）：dispatch_once&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once方法。使用 dispatch_once方法能保证某段代码在程序运行过程中只被执行 1 次，并且即使在多线程的环境下，dispatch_once也可以保证线程安全。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 一次性代码（只执行一次）dispatch_once
 */
- (void)once {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        // 只执行 1 次的代码（这里面默认是线程安全的）
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-gcd-快速迭代方法dispatch_apply&quot;&gt;4. GCD 快速迭代方法：dispatch_apply&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的方法 dispatch_apply。dispatch_apply按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果是在串行队列中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行。但是这样就体现不出快速迭代的意义了。&lt;/p&gt;

&lt;p&gt;我们可以利用并发队列进行异步执行。比如说遍历 0~5 这 6 个数字，for 循环的做法是每次取出一个元素，逐个遍历。dispatch_apply 可以 在多个线程中同时（异步）遍历多个数字。&lt;/p&gt;

&lt;p&gt;还有一点，无论是在串行队列，还是并发队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 dispatch_group_wait方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 快速迭代方法 dispatch_apply
 */
- (void)apply {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    NSLog(@&quot;apply---begin&quot;);
    dispatch_apply(6, queue, ^(size_t index) {
        NSLog(@&quot;%zd---%@&quot;,index, [NSThread currentThread]);
    });
    NSLog(@&quot;apply---end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:05:04.715266+0800 YSC-GCD-demo[17771:4285619] apply---begin
   
 2019-08-08 15:05:04.715492+0800 YSC-GCD-demo[17771:4285619] 0---{number = 1, name = main}
   
 2019-08-08 15:05:04.715516+0800 YSC-GCD-demo[17771:4285722] 1---{number = 3, name = (null)}
   
 2019-08-08 15:05:04.715526+0800 YSC-GCD-demo[17771:4285720] 3---{number = 5, name = (null)}
   
 2019-08-08 15:05:04.715564+0800 YSC-GCD-demo[17771:4285721] 2---{number = 7, name = (null)}
   
 2019-08-08 15:05:04.715555+0800 YSC-GCD-demo[17771:4285719] 4---{number = 6, name = (null)}
   
 2019-08-08 15:05:04.715578+0800 YSC-GCD-demo[17771:4285728] 5---{number = 4, name = (null)}
   
 2019-08-08 15:05:04.715677+0800 YSC-GCD-demo[17771:4285619] apply---end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是 apply—end 一定在最后执行。这是因为 dispatch_apply 方法会等待全部任务执行完毕。&lt;/p&gt;

&lt;h2 id=&quot;5-gcd-队列组dispatch_group&quot;&gt;5. GCD 队列组：dispatch_group&lt;/h2&gt;

&lt;p&gt;有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用队列组的 dispatch_group_async先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave组合来实现 dispatch_group_async。&lt;/li&gt;
  &lt;li&gt;调用队列组的 dispatch_group_notify回到指定线程执行任务。或者使用 dispatch_group_wait回到当前线程继续向下执行（会阻塞当前线程）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-dispatch_group_notify&quot;&gt;1) dispatch_group_notify&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 队列组 dispatch_group_notify
 */
- (void)groupNotify {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);
    
    dispatch_group_t group =  dispatch_group_create();
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步任务 1、任务 2 都执行完毕后，回到主线程执行下边任务
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        NSLog(@&quot;group---end&quot;);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:07:21.601734+0800 YSC-GCD-demo[17813:4293874] currentThread---{number = 1, name = main}
   
 2019-08-08 15:07:21.601871+0800 YSC-GCD-demo[17813:4293874] group---begin
   
 2019-08-08 15:07:23.604854+0800 YSC-GCD-demo[17813:4294048] 2---{number = 4, name = (null)}
   
 2019-08-08 15:07:23.604852+0800 YSC-GCD-demo[17813:4294053] 1---{number = 3, name = (null)}
   
 2019-08-08 15:07:25.606067+0800 YSC-GCD-demo[17813:4293874] 3---{number = 1, name = main}
   
 2019-08-08 15:07:25.606255+0800 YSC-GCD-demo[17813:4293874] group---end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从 dispatch_group_notify 相关代码运行输出结果可以看出：&lt;/p&gt;

&lt;p&gt;当所有任务都执行完成之后，才执行 dispatch_group_notify 相关 block 中的任务。&lt;/p&gt;

&lt;h3 id=&quot;2-dispatch_group_wait&quot;&gt;2) dispatch_group_wait&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 队列组 dispatch_group_wait
 */
- (void)groupWait {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);
    
    dispatch_group_t group =  dispatch_group_create();
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    
    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    
    NSLog(@&quot;group---end&quot;);
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:09:12.441729+0800 YSC-GCD-demo[17844:4299926] currentThread---{number = 1, name = main}
   
 2019-08-08 15:09:12.441870+0800 YSC-GCD-demo[17844:4299926] group---begin
   
 2019-08-08 15:09:14.445790+0800 YSC-GCD-demo[17844:4300046] 2---{number = 4, name = (null)}
   
 2019-08-08 15:09:14.445760+0800 YSC-GCD-demo[17844:4300043] 1---{number = 3, name = (null)}
   
 2019-08-08 15:09:14.446039+0800 YSC-GCD-demo[17844:4299926] group---end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从 dispatch_group_wait 相关代码运行输出结果可以看出：&lt;/p&gt;

&lt;p&gt;当所有任务执行完成之后，才执行 dispatch_group_wait 之后的操作。但是，使用dispatch_group_wait 会阻塞当前线程。&lt;/p&gt;

&lt;h3 id=&quot;3-dispatch_group_enterdispatch_group_leave&quot;&gt;3) dispatch_group_enter、dispatch_group_leave&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;dispatch_group_enter标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数 +1&lt;/li&gt;
  &lt;li&gt;dispatch_group_leave标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数 -1。&lt;/li&gt;
  &lt;li&gt;当 group 中未执行完毕任务数为0的时候，才会使 dispatch_group_wait解除阻塞，以及执行追加到 dispatch_group_notify中的任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 队列组 dispatch_group_enter、dispatch_group_leave
 */
- (void)groupEnterAndLeave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);
    
    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        dispatch_group_leave(group);
    });
    
    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        
        dispatch_group_leave(group);
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步操作都执行完毕后，回到主线程.
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    
        NSLog(@&quot;group---end&quot;);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:13:17.983283+0800 YSC-GCD-demo[17924:4314716] currentThread---{number = 1, name = main}
   
 2019-08-08 15:13:17.983429+0800 YSC-GCD-demo[17924:4314716] group---begin
   
 2019-08-08 15:13:19.988898+0800 YSC-GCD-demo[17924:4314816] 2---{number = 3, name = (null)}
   
 2019-08-08 15:13:19.988888+0800 YSC-GCD-demo[17924:4314808] 1---{number = 4, name = (null)}
   
 2019-08-08 15:13:21.990450+0800 YSC-GCD-demo[17924:4314716] 3---{number = 1, name = main}
   
 2019-08-08 15:13:21.990711+0800 YSC-GCD-demo[17924:4314716] group---end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从 dispatch_group_enter、dispatch_group_leave 相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的dispatch_group_enter、dispatch_group_leave 组合，其实等同于dispatch_group_async。&lt;/p&gt;

&lt;h2 id=&quot;gcd-信号量dispatch_semaphore&quot;&gt;GCD 信号量：dispatch_semaphore&lt;/h2&gt;

&lt;p&gt;GCD 中的信号量是指 &lt;strong&gt;Dispatch Semaphore&lt;/strong&gt;，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 &lt;strong&gt;Dispatch Semaphore&lt;/strong&gt; 中，使用计数来完成这个功能，计数小于 0 时等待，不可通过。计数为 0 或大于 0 时，计数减 1 且不等待，可通过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dispatch Semaphore&lt;/strong&gt; 提供了三个方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;dispatch_semaphore_create：创建一个 Semaphore 并初始化信号的总量&lt;/li&gt;
  &lt;li&gt;dispatch_semaphore_signal：发送一个信号，让信号总量加 1&lt;/li&gt;
  &lt;li&gt;dispatch_semaphore_wait：可以使总信号量减 1，信号总量小于 0 时就会一直等待（阻塞所在线程），否则就可以正常执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。&lt;/p&gt;

&lt;p&gt;Dispatch Semaphore 在实际开发中主要用于：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保持线程同步，将异步执行任务转换为同步执行任务&lt;/li&gt;
  &lt;li&gt;保证线程安全，为线程加锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-dispatch-semaphore-线程同步&quot;&gt;1) Dispatch Semaphore 线程同步&lt;/h3&gt;

&lt;p&gt;我们在开发中，会遇到这样的需求��异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSArray *)tasksForKeyPath:(NSString *)keyPath {
    __block NSArray *tasks = nil;
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {
            tasks = dataTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {
            tasks = uploadTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {
            tasks = downloadTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {
            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];
        }

        dispatch_semaphore_signal(semaphore);
    }];

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

    return tasks;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * semaphore 线程同步
 */
- (void)semaphoreSync {
    
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    __block int number = 0;
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        
        number = 100;
        
        dispatch_semaphore_signal(semaphore);
    });
    
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;semaphore---end,number = %zd&quot;,number);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:16:56.781543+0800 YSC-GCD-demo[17988:4325744] currentThread---{number = 1, name = main}
   
 2019-08-08 15:16:56.781698+0800 YSC-GCD-demo[17988:4325744] semaphore---begin
   
 2019-08-08 15:16:58.785232+0800 YSC-GCD-demo[17988:4325867] 1---{number = 3, name = (null)}
   
 2019-08-08 15:16:58.785432+0800 YSC-GCD-demo[17988:4325744] semaphore---end,number = 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从 Dispatch Semaphore 实现线程同步的代码可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;semaphore—end是在执行完 number = 100;之后才打印的。而且输出结果 number 为 100。这是因为 异步执行不会做任何等待，可以继续执行任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;执行顺如下：
    1. semaphore 初始创建时计数为 0。
    2. 异步执行将 任务 1追加到队列之后，不做等待，接着执行 dispatch_semaphore_wait方法，semaphore 减 1，此时 semaphore == -1，当前线程进入等待状态。
    3. 然后，异步任务 1 开始执行。任务 1 执行到 dispatch_semaphore_signal之后，总信号量加 1，此时 semaphore == 0，正在被阻塞的线程（主线程）恢复继续执行。
    4. 最后打印 semaphore—end,number = 100。&lt;/p&gt;

&lt;p&gt;这样就实现了线程同步，将异步执行任务转换为同步执行任务。&lt;/p&gt;

&lt;h3 id=&quot;2-dispatch-semaphore-线程安全和线程同步为线程加锁&quot;&gt;2) Dispatch Semaphore 线程安全和线程同步（为线程加锁）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;线程安全&lt;/strong&gt;：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;

&lt;p&gt;若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线程同步&lt;/strong&gt;：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。&lt;/p&gt;

&lt;p&gt;举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。&lt;/p&gt;

&lt;p&gt;下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。&lt;/p&gt;

&lt;p&gt;场景：总共有 50 张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。&lt;/p&gt;

&lt;h4 id=&quot;非线程安全不使用-semaphore先来看看不考虑线程安全的代码&quot;&gt;非线程安全（不使用 semaphore）先来看看不考虑线程安全的代码：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 非线程安全：不使用 semaphore
 * 初始化火车票数量、卖票窗口（非线程安全）、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票（非线程安全）
 */
- (void)saleTicketNotSafe {
    while (1) {
        
        if (self.ticketSurplusCount &amp;gt; 0) {  // 如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { // 如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果（部分）：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:21:39.772655+0800 YSC-GCD-demo[18071:4340555] currentThread---{number = 1, name = main}
   
 2019-08-08 15:21:39.772790+0800 YSC-GCD-demo[18071:4340555] semaphore---begin
   
 2019-08-08 15:21:39.773101+0800 YSC-GCD-demo[18071:4340604] 剩余票数：48 窗口：{number = 4, name = (null)}
   
 2019-08-08 15:21:39.773115+0800 YSC-GCD-demo[18071:4340605] 剩余票数：49 窗口：{number = 3, name = (null)}
   
 2019-08-08 15:21:39.975041+0800 YSC-GCD-demo[18071:4340605] 剩余票数：47 窗口：{number = 3, name = (null)}
   
 2019-08-08 15:21:39.975037+0800 YSC-GCD-demo[18071:4340604] 剩余票数：47 窗口：{number = 4, name = (null)}
   
 2019-08-08 15:21:40.176567+0800 YSC-GCD-demo[18071:4340604] 剩余票数：46 窗口：{number = 4, name = (null)}
   
 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。&lt;/p&gt;

&lt;h4 id=&quot;线程安全使用-semaphore-加锁考虑线程安全的代码&quot;&gt;线程安全（使用 semaphore 加锁）考虑线程安全的代码：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 semaphore 加锁
 * 初始化火车票数量、卖票窗口（线程安全）、并开始卖票
 */
- (void)initTicketStatusSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);
    
    semaphoreLock = dispatch_semaphore_create(1);
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketSafe];
    });
}

/**
 * 售卖火车票（线程安全）
 */
- (void)saleTicketSafe {
    while (1) {
        // 相当于加锁
        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);
        
        if (self.ticketSurplusCount &amp;gt; 0) {  // 如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { // 如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            
            // 相当于解锁
            dispatch_semaphore_signal(semaphoreLock);
            break;
        }
        
        // 相当于解锁
        dispatch_semaphore_signal(semaphoreLock);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2019-08-08 15:23:58.819891+0800 YSC-GCD-demo[18116:4348091] currentThread---{number = 1, name = main}
   
 2019-08-08 15:23:58.820041+0800 YSC-GCD-demo[18116:4348091] semaphore---begin
   
 2019-08-08 15:23:58.820305+0800 YSC-GCD-demo[18116:4348159] 剩余票数：49 窗口：{number = 3, name = (null)}
   
 2019-08-08 15:23:59.022165+0800 YSC-GCD-demo[18116:4348157] 剩余票数：48 窗口：{number = 4, name = (null)}
   
 2019-08-08 15:23:59.225299+0800 YSC-GCD-demo[18116:4348159] 剩余票数：47 窗口：{number = 3, name = (null)}
   
 ...
   
 2019-08-08 15:24:08.355977+0800 YSC-GCD-demo[18116:4348157] 剩余票数：2 窗口：{number = 4, name = (null)}
   
 2019-08-08 15:24:08.559201+0800 YSC-GCD-demo[18116:4348159] 剩余票数：1 窗口：{number = 3, name = (null)}
   
 2019-08-08 15:24:08.759630+0800 YSC-GCD-demo[18116:4348157] 剩余票数：0 窗口：{number = 4, name = (null)}
   
 2019-08-08 15:24:08.965100+0800 YSC-GCD-demo[18116:4348159] 所有火车票均已售完
   
 2019-08-08 15:24:08.965440+0800 YSC-GCD-demo[18116:4348157] 所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看出，在考虑了线程安全的情况下，使用 dispatch_semaphore&lt;/p&gt;

&lt;p&gt;机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/iOS_GCD/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/iOS_GCD/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>MAC 端口被占用 address already in use</title>
        <description>&lt;p&gt;Error: listen EADDRINUSE: address already in use :::8700&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo lsof -i:8700
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;显示如下
ruby    91953 syswin    9u  IPv4 0x601da28cc087d05f      0t0  TCP localhost:terabase (LISTEN)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 杀死进程
sudo kill -9 8700 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 19 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</guid>
        
        <category>mark</category>
        
        
      </item>
    
      <item>
        <title>Shell 批量实现iOS的懒加载</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
iosBatchLazyCode&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;UIButton&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
           &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; buttonWithType:UIButtonTypeCustom];&quot;&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;else
           &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;[[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; alloc]init];&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi
  &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;
- (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; *)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;{
    if (_&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; == nil) {
        _&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
    }
    return _&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;;
}&quot;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#追加一行空格&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'\n'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; propertys.txt

&lt;span class=&quot;c&quot;&gt;#读取文件存数组&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;line
&lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lineStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;noneSpaceStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lineStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;// /&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    ARR[&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$noneSpaceStr&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;i+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &amp;lt; propertys.txt

&lt;span class=&quot;c&quot;&gt;#格式化输出到out.txt&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;str &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ARR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;#*)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;#*&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%*;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    iosBatchLazyCode &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; out.txt 


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 19 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/run_jekyll_error/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/run_jekyll_error/</guid>
        
        <category>shell</category>
        
        
      </item>
    
      <item>
        <title>ruby字符串格式化、进制转换、小数位数控制</title>
        <description>&lt;h2 id=&quot;ruby-字符串格式化和进制转换&quot;&gt;ruby 字符串格式化和进制转换&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;%05d&quot; % 123 结果是 &quot;00123&quot;
&quot;%02X&quot; % 10 结果是 &quot;0A&quot;
&quot;%03x&quot; % 10 结果是 &quot;00a&quot;
&quot;%010x&quot; % 10 结果是 &quot;000000000a&quot; (前缀9个0)
&quot;%10x&quot; %10 结果是 &quot;         a&quot;  （前缀9个空格）
'ff'.to_i(16)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;ruby实现ip转数字&quot;&gt;ruby实现ip转数字&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#数字转ip=》先将数字转换为16进制，然后拆分转十进制
def conver_ip(data)
    @str=&quot;%x&quot; % data
    @str=@str.reverse
    # p @str,@str.length
    ip1=(@str[1]+@str[0]).to_i(16).to_s
    ip2=(@str[3]+@str[2]).to_i(16).to_s
    ip3=(@str[5]+@str[4]).to_i(16).to_s
    if @str.length &amp;lt;= 7
        ip4=@str[6].to_i(16).to_s
    else 
        ip4=(@str[7]+@str[6]).to_i(16).to_s
    end
    puts ip4+&quot;.&quot;+ip3+&quot;.&quot;+ip2+&quot;.&quot;+ip1
end
#ip转数字=》先将ip拆分转16进制，连接后转十进制
def ip_conver(str_ip)
    @ip_16=''
    str_ip.split('.').each do |k|
        k=&quot;%02x&quot; % k
        @ip_16=@ip_16+k.to_s
    end
    puts @ip_16.to_i(16)
end
#测试通过
conver_ip('16777471')
ip_conver('1.0.0.255')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;小数位数控制&quot;&gt;小数位数控制&lt;/h2&gt;

&lt;p&gt;ruby的Kernal.sprintf()可以实现保留两位小数的方法，format是sprintf的alias。format(pattern, value)：其中pattern表示要格式化形式，在这里我们用“%.2f”,表示保留小数点后2位数字，当然我们还可以写成“%05.2f”,表示整个字符串最少5位数(不包括小数点)，如果value少于5位用”0”占位。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;%0.2f&quot;% 11.329    
format(&quot;%0.2f&quot;, 11.329)    
2. 11.329.round(1)  # -----&amp;gt;  11.3      
11.329.round(2)   #-----&amp;gt;  11.33
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;转义字符&quot;&gt;转义字符&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;strstr = str.gsub('&amp;lt;', '&amp;amp;lt;')  
strstr = str.gsub('&amp;gt;', '&amp;amp;gt;')  
strstr = str.gsub(/['&quot;]/, '&amp;amp;quot;')  
strstr = str.lstrip                            #去掉前后空格  
strstr = str.delete(&quot;\n\r&quot;)                #去掉换行符  
strstr = str.delete(&quot; &quot;)                    #去掉tab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 19 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/ruby%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0%E6%8E%A7%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/ruby%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0%E6%8E%A7%E5%88%B6/</guid>
        
        <category>ruby</category>
        
        
      </item>
    
      <item>
        <title>运行jekyll报错</title>
        <description>&lt;p&gt;运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;报错&lt;code class=&quot;highlighter-rouge&quot;&gt;You have already activated public_suffix 4.0.6, but your Gemfile requires public_suffix 3.0.3. Prepending 'bundle exec'to your command may solve this. (Gem::LoadError)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bundle exec jekyll serve

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 19 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/Shell_lazy_load/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/Shell_lazy_load/</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>Ruby笔记</title>
        <description>&lt;p&gt;学习Ruby过程中的一些笔记&lt;/p&gt;

&lt;h2 id=&quot;1invalid-byte-sequence-in-utf-8-argumenterror&quot;&gt;1、Invalid byte sequence in UTF-8 (ArgumentError)&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ! file_content.valid_encoding?
  s = file_content.encode(&quot;UTF-16be&quot;, :invalid=&amp;gt;:replace, :replace=&amp;gt;&quot;?&quot;).encode('UTF-8')
  s.gsub(/dr/i,'med')
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;2ruby-里的-q-q-w-w-x-r-s-i&quot;&gt;2、&lt;a href=&quot;https://ruby-china.org/topics/18512&quot;&gt;Ruby 里的 %Q, %q, %W, %w, %x, %r, %s, %i&lt;/a&gt; &lt;/h2&gt;
&lt;h2 id=&quot;3podfile-的解析逻辑&quot;&gt;3、&lt;a href=&quot;https://blog.csdn.net/Desgard_Duan/article/details/108633619?spm=1001.2014.3001.5502&quot;&gt;Podfile 的解析逻辑&lt;/a&gt;&lt;/h2&gt;

</description>
        <pubDate>Mon, 19 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/Ruby_note/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/Ruby_note/</guid>
        
        <category>ruby</category>
        
        
      </item>
    
      <item>
        <title>Shell批量重命名</title>
        <description>&lt;h2 id=&quot;第一种方法&quot;&gt;第一种方法&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CURRENT_DIR=`pwd`

for dir in *
do
    if [ -d $dir ];then
        for file in $dir/*
        do
            NEW_FILE=${file/XXXXXXX/}
            if [ &quot;$NEW_FILE&quot; != &quot;$file&quot; ] ;then
                mv &quot;${CURRENT_DIR}/$file&quot; &quot;${CURRENT_DIR}/${NEW_FILE}&quot;
                if [ $? -eq 0 ] ;then
                    echo &quot;${CURRENT_DIR}/${NEW_FILE}&quot;
                    echo &quot;替换成功&quot;
                fi
            fi
            #echo $CURRENT_DIR ----- $dir --- $file
            
        done
    fi
    
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;其他实现&quot;&gt;其他实现&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0、用类似 GPRename 这样的图形软件进行批量重命名

#1、删除所有的 .bak 后缀：
rename 's/\.bak$//' *.bak

#2、把 .jpe 文件后缀修改为 .jpg：
rename 's/\.jpe$/\.jpg/' *.jpe

#3、把所有文件的文件名改为小写：
rename 'y/A-Z/a-z/' *

#4、将 abcd.jpg 重命名为 abcd_efg.jpg：
for var in *.jpg; do mv &quot;$var&quot; &quot;${var%.jpg}_efg.jpg&quot;; done

#5、将 abcd_efg.jpg 重命名为 abcd_lmn.jpg：
for var in *.jpg; do mv &quot;$var&quot; &quot;${var%_efg.jpg}_lmn.jpg&quot;; done

#6、把文件名中所有小写字母改为大写字母：
for var in `ls`; do mv -f &quot;$var&quot; `echo &quot;$var&quot; |tr a-z A-Z`; done

#7、把格式 *_?.jpg 的文件改为 *_0?.jpg：
for var in `ls *_?.jpg`; do mv &quot;$var&quot; `echo &quot;$var&quot; |awk -F '_' '{print $1 &quot;_0&quot; $2}'`; done

#8、把文件名的前三个字母变为 vzomik：
for var in `ls`; do mv -f &quot;$var&quot; `echo &quot;$var&quot; |sed 's/^.../vzomik/'`; done

#9、把文件名的后四个字母变为 vzomik：
for var in `ls`; do mv -f &quot;$var&quot; `echo &quot;$var&quot; |sed 's/....$/vzomik/'`; done

#10. 把.txt变成.txt_bak 的后缀
ls *.txt|xargs -n1 -i{} mv {} {}_bak
# xargs -n1 –i{} 类似for循环，-n1意思是一个一个对象的去处理，-i{} 把前面的对象使用{}取代，mv {} {}_bak 相当于 mv 1.txt 1.txt_bak

find ./*.txt -exec mv {} {}_bak \;  
#这个命令中也是把{}作为前面find出来的文件的替代符，后面的”\”为”;”的脱意符，不然shell会把分号作为该行命令的结尾.


==================================================================

既然要批量替换文件名，那么肯定得用一个for循环依次遍历指定目录下的每个文件。对于每个文件，假如该文件的名称为name.oldext，那么我们必须原始文件名中挖出name，再将它与新的文件扩展名newext拼接形成新的文件名name.newext。依照这样的思路，就诞生了下面的脚本：
#!/bin/bash
oldext=&quot;JPG&quot;
newext=&quot;jpg&quot;
dir=$(eval pwd)

for file in $(ls $dir | grep .$oldext)
        do
        name=$(ls $file | cut -d. -f1)
        mv $file ${name}.$newext
        done
echo &quot;change JPG=====&amp;gt;jpg done!&quot;

        下面对针对这个程序作简单说明：
1.变量oldext和newext分别指定旧的扩展名和新的扩展名。dir指定文件所在目录；
2.“ls $dir | grep .$oldext”用来在指定目录dir中获取扩展名为旧扩展名的所有文件；
3.在循环体内先利用cut命令将文件名中“.”之前的字符串剪切出来，并赋值给name变量；接着将当前的文件名重命名为新的文件名。
        通过这个脚本，所有照片的扩展名都成功修改。为了使这个脚本更具有通用型，我们可以增加几条read命令实现脚本和用户之间的交互。改进版的脚本如下：
#!/bin/bash
read -p &quot;old extension:&quot; oldext
read -p &quot;new extension:&quot; newext
read -p &quot;The directory:&quot; dir
cd $dir

for file in $(ls $dir | grep .$oldext)
        do
        name=$(ls $file | cut -d. -f1)
        mv $file ${name}.$newext
        echo &quot;$name.$oldext ====&amp;gt; $name.$newext&quot;
        done

echo &quot;all files has been modified.&quot;
        修改后的脚本可以批量修改任意扩展名。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Shell批量重命名文件名
#!/bin/sh
#替换文件名中的空格
find . -name &quot;* *&quot;|
while read name;do
    na=$(echo $name | tr ' ' '_')
    mv &quot;$name&quot; $na
done

#将文件名替换成1、2、3、4、5、6等文件名，后缀名保持不变（例如test.log --&amp;gt;1.log）
for file in `find . -type f -name &quot;*&quot;`;do 
dirname=`dirname $file`

 i=`expr $i + 1`;
#获取文件后缀名
 P=&quot;${file##*.}&quot;
echo $file $dirname/$i.$P;

mv $file $dirname/$i.$P;
done

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 17 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/Shell_rename/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/Shell_rename/</guid>
        
        <category>Shell</category>
        
        
      </item>
    
      <item>
        <title>Shell笔记</title>
        <description>&lt;h2 id=&quot;1mac下shell别名可以在etcbashrc-或者bash_profile添加&quot;&gt;1、Mac下shell别名，可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/bashrc&lt;/code&gt; 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bash_profile&lt;/code&gt;添加&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alias grep='grep --color=auto'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;2变量赋值等号两边每空格&quot;&gt;2、变量赋值等号两边每空格&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A=&quot;Hello world&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;3expr-运算符两边有空格&quot;&gt;3、expr 运算符两边有空格&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;expr 2 + 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;4条件判断-条件判断---条件判断-两边有空格&quot;&gt;4、条件判断[ 条件判断 ] [[ 条件判断 ]]两边有空格&lt;/h2&gt;
&lt;h2 id=&quot;5条件判断中运算符两边有空格&quot;&gt;5、条件判断中运算符两边有空格&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ ! $(id -u) -eq 0 ] &amp;amp;&amp;amp; echo &quot;ABC&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;5表达式&quot;&gt;5、表达式&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#表达式空格可有可无，两个表达式相等
$((1+3))
$[1+3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;6类c风格a1赋值ab判等&quot;&gt;6、类C风格((A=1))赋值,((A==B))判等&lt;/h2&gt;

&lt;h2 id=&quot;7如果需要在文件中替换多个相同的字符串需要添加global参数g即&quot;&gt;7、如果需要在文件中替换多个相同的字符串，需要添加global参数g，即:&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sed -i &quot;.bak&quot; &quot;s/1.*/aa\/bb/g&quot; test.txt
或者
#https://blog.csdn.net/toopoo/article/details/104432196
sed -i &quot;.bak&quot; &quot;s|1.*|aa/bb|g&quot; test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;8字符串操作&quot;&gt;8、字符串操作&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;${#string} : $string 的长度
${string:position} : 从$position位置开始的子字符串
${string:position:length} : 从$position位置开始，长度为length的子字符串
${string#substring} : 从头开始，删除最短匹配$substring的字符串
${string##substring} : 从头开始，删除最长匹配$substring的字符串
${string%substring} : 从结尾开始，删除最短匹配$substring的字符串
${string%%substring} : 从结尾开始，删除最长匹配$substring的字符串
${string/str1/str2} : 使用str2替换第一个匹配的$str1
${string//str1/str2} : 使用str2替换所有匹配的$str1
${string/#str1/str2} : 如果$string的前缀和$str1匹配,用$str2替换$str1
${string/%str1/str2} : 如果$string的后缀和$str1匹配，用$str2替换$str1


${file-my.file.txt} ：假如$file 沒有设定，則使用my.file.txt 作传回值。(空值及非空值時不作处理) 
${file:-my.file.txt} ：假如$file 沒有設定或為空值，則使用my.file.txt 作傳回值。(非空值時不作处理)
${file+my.file.txt} ：假如$file 設為空值或非空值，均使用my.file.txt 作傳回值。(沒設定時不作处理)
${file:+my.file.txt} ：若$file 為非空值，則使用my.file.txt 作傳回值。(沒設定及空值時不作处理)
${file=my.file.txt} ：若$file 沒設定，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(空值及非空值時不作处理)
${file:=my.file.txt} ：若$file 沒設定或為空值，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(非空值時不作处理)
${file?my.file.txt} ：若$file 沒設定，則將my.file.txt 輸出至STDERR。(空值及非空值時不作处理)
${file:?my.file.txt} ：若$file 没设定或为空值，则将my.file.txt 输出至STDERR。(非空值時不作处理)

${#var} 可计算出变量值的长度：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;9从文本中读取字符串命令执行&quot;&gt;9、从文本中读取字符串命令执行&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;awk '/^TN/{ cmd=$0; system(cmd) }' $SRCROOT/../README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;10获取当前目录&quot;&gt;10、获取当前目录&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;project_path=$(cd &quot;`dirname &quot;$0&quot;`&quot;; pwd)
#当前目录
cur_dir=$(pwd)
#上级目录
highter_dir=$(dirname &quot;$(pwd)&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;获取路径最后一个名字&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;project_path=$(cd &quot;`dirname &quot;$0&quot;`&quot;; pwd)
#当前目录
cur_dir=$(pwd)
#上级目录
highter_dir=$(dirname &quot;$(pwd)&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;11懒加载代码&quot;&gt;11、懒加载代码&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
iosBatchLazyCode&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;UIButton&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
   		&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; buttonWithType:UIButtonTypeCustom];&quot;&lt;/span&gt;
   	&lt;span class=&quot;k&quot;&gt;else
   		&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;[[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; alloc]init];&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;fi
  &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;
- (&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; *)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;{
    if (_&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; == nil) {
        _&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
    }
    return _&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;;
}&quot;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;#追加一行空格&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'\n'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; propertys.txt

&lt;span class=&quot;c&quot;&gt;#读取文件存数组&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;line
&lt;span class=&quot;k&quot;&gt;do
	&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lineStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;noneSpaceStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lineStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;// /&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    ARR[&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$noneSpaceStr&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;i+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &amp;lt; propertys.txt

&lt;span class=&quot;c&quot;&gt;#格式化输出到out.txt&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;str &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ARR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do
	&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;#*)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;#*&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%*;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
	iosBatchLazyCode &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; out.txt 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;12创建文件&quot;&gt;12、创建文件&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RESOURCES_TO_COPY=${PODS_ROOT}/resources-to-copy-${TARGETNAME}.txt
&amp;gt; &quot;$RESOURCES_TO_COPY&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;13字符串正则匹配&quot;&gt;13、字符串正则匹配&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;str1=我是中国人
if [[ &quot;$str1&quot; == 我是* ]]; then
     echo 有前缀
else
     echo 没有前缀
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 01 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/Shell_note/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/Shell_note/</guid>
        
        <category>Shell</category>
        
        
      </item>
    
      <item>
        <title>iOS 优化篇 - 启动优化之Clang插桩实现二进制重排</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;自从抖音团队分享了这篇 &lt;a href=&quot;https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q&quot;&gt;抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%&lt;/a&gt; 启动优化文章后 , 二进制重排优化 &lt;code class=&quot;highlighter-rouge&quot;&gt;pre-main&lt;/code&gt; 阶段的启动时间自此被大家广为流传 .&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;本篇文章首先讲述下二进制重排的原理 , ( 因为抖音团队在上述文章中原理部分大多是点到即止 , 多数朋友看完并没有什么实际收获 ) . 然后将结合 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插桩的方式&lt;/strong&gt; 来实际讲述和演练一下如何解决抖音团队遗留下来的这一问题 :&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hook Objc_msgSend 无法解决的 纯swift , block , c++ 方法&lt;/code&gt; .&lt;/p&gt;

  &lt;p&gt;来达到完美的二进制重排方案 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;( 本篇文章由于会从原理角度讲解 , 有些已经比较熟悉的同学可能会觉得节奏偏啰嗦 , 为了照顾大部分同学 , 大家自行根据目录跳过即可 . )&lt;/p&gt;

&lt;p&gt;了解二进制重排之前 , 我们需要了解一些前导知识 , 以及二进制重排是为了解决什么问题 .&lt;/p&gt;

&lt;h2 id=&quot;虚拟内存与物理内存&quot;&gt;虚拟内存与物理内存&lt;/h2&gt;

&lt;p&gt;在本篇文章里 , 笔者就不通过教科书或者大多数资料的方式来讲述这个概念了 . 我们通过实际问题和其对应的解决方式来看这个技术 &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; 概念 .&lt;/p&gt;

&lt;p&gt;在计算机领域 , 任何一个技术 &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; 概念 , 都是为了解决实际的问题而诞生的 .&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在早期的计算机中 , 并没有虚拟内存的概念 , 任何应用被从磁盘中加载到运行内存中时 , 都是完整加载和按序排列的 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17180fef76d0d455.webp&quot; alt=&quot;&quot; /&gt;
那么因此 , 就会出现两个问题 :&lt;/p&gt;

&lt;h3 id=&quot;使用物理内存时遗留的问题&quot;&gt;使用物理内存时遗留的问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;安全问题&lt;/code&gt; : 由于在内存条中使用的都是真实物理地址 , 而且内存条中各个应用进程都是按顺序依次排列的 . 那么在 &lt;code class=&quot;highlighter-rouge&quot;&gt;进程1&lt;/code&gt; 中通过地址偏移就可以访问到 &lt;code class=&quot;highlighter-rouge&quot;&gt;其他进程&lt;/code&gt; 的内存 .&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;效率问题&lt;/code&gt; : 随着软件的发展 , 一个软件运行时需要占用的内存越来越多 , 但往往用户并不会用到这个应用的所有功能 , 造成很大的内存浪费 , 而后面打开的进程往往需要排队等待 .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决上述两个问题 , 虚拟内存应运而生 .&lt;/p&gt;

&lt;h3 id=&quot;虚拟内存工作原理&quot;&gt;虚拟内存工作原理&lt;/h3&gt;

&lt;p&gt;引用了虚拟内存后 , 在我们进程中认为自己有一大片连续的内存空间实际上是虚拟的 , 也就是说从 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x000000&lt;/code&gt; ~ &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffff&lt;/code&gt; 我们是都可以访问的 . 但是实际上这个内存地址只是一个虚拟地址 , 而这个虚拟地址通过一张映射表映射后才可以获取到真实的物理地址 .&lt;/p&gt;

&lt;p&gt;什么意思呢 ?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;实际上我们可以理解为 , 系统对真实物理内存访问做了一层限制 , 只有被写到映射表中的地址才是被认可可以访问的 .&lt;/li&gt;
    &lt;li&gt;例如 , 虚拟地址 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x000000&lt;/code&gt; ~ &lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffff&lt;/code&gt; 这个范围内的任意地址我们都可以访问 , 但是这个虚拟地址对应的实际物理地址是计算机来随机分配到内存页上的 .&lt;/li&gt;
    &lt;li&gt;这里提到了实际物理内存分页的概念 , 下面会详细讲述 .&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;可能大家也有注意到 , 我们在一个工程中获取的地址 , 同时在另一个工程中去访问 , 并不能访问到数据 , 其原理就是虚拟内存 .&lt;/p&gt;

&lt;p&gt;整个虚拟内存的工作原理这里用一张图来展示 :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17181bac8873718e.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;虚拟内存解决进程间安全问题原理&quot;&gt;虚拟内存解决进程间安全问题原理&lt;/h3&gt;

&lt;p&gt;显然 , 引用虚拟内存后就不存在通过偏移可以访问到其他进程的地址空间的问题了 .&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为每个进程的映射表是单独的 , 在你的进程中随便你怎么访问 , 这些地址都是受映射表限制的 , 其真实物理地址永远在规定范围内 , 也就不存在通过偏移获取到其他进程的内存空间的问题了 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且实际上 , 每次应用被加载到内存中 , 实际分配的物理内存并不一定是固定或者连续的 , 这是因为内存分页以及懒加载以及 &lt;a href=&quot;https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%8A%A0%E8%BD%BD?fromtitle=aslr&amp;amp;fromid=5779647&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ASLR&lt;/code&gt;&lt;/a&gt; 所解决的安全问题 .&lt;/p&gt;

&lt;h4 id=&quot;cpu-寻址过程&quot;&gt;cpu 寻址过程&lt;/h4&gt;

&lt;p&gt;引入虚拟内存后 , &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu&lt;/code&gt; 在通过虚拟内存地址访问数据的过程如下 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过虚拟内存地址 , 找到对应进程的映射表 .&lt;/li&gt;
  &lt;li&gt;通过映射表找到其对应的真实物理地址 , 进而找到数据 .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个过程被称为 &lt;strong&gt;地址翻译&lt;/strong&gt; , 这个过程是由操作系统以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu&lt;/code&gt; 上集成的一个 &lt;a href=&quot;https://baike.baidu.com/item/MMU/4542218?fr=aladdin&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;硬件单元 MMU&lt;/code&gt;&lt;/a&gt; 协同来完成的 .&lt;/p&gt;

&lt;p&gt;那么安全问题解决了以后 , 效率问题如何解决呢 ?&lt;/p&gt;

&lt;h3 id=&quot;虚拟内存解决效率问题&quot;&gt;虚拟内存解决效率问题&lt;/h3&gt;

&lt;p&gt;刚刚提到虚拟内存和物理内存通过映射表进行映射 , 但是这个映射并不可能是一一对应的 , 那样就太过浪费内存了 . 为了解决效率问题 , 实际上真实物理内存是分页的 . 而映射表同样是以页为单位的 .&lt;/p&gt;

&lt;p&gt;换句话说 , 映射表只会映射到一页 , 并不会映射到具体每一个地址 .&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;linux&lt;/code&gt; 系统中 , 一页内存大小为 &lt;code class=&quot;highlighter-rouge&quot;&gt;4KB&lt;/code&gt; , 在不同平台可能各有不同 .&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Mac OS&lt;/code&gt; 系统中 , 一页为 &lt;code class=&quot;highlighter-rouge&quot;&gt;4KB&lt;/code&gt; ,&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt; 系统中 , 一页为 &lt;code class=&quot;highlighter-rouge&quot;&gt;16KB&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;pagesize&lt;/code&gt; 命令直接查看 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17181d8f22b995e3.webp&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/images/posts/iOS/optimize/17181ebc66588a31.webp&quot; alt=&quot;&quot; /&gt;
那么为什么说内存分页就可以解决内存浪费的效率问题呢 ?&lt;/p&gt;

&lt;h3 id=&quot;内存分页原理&quot;&gt;内存分页原理&lt;/h3&gt;

&lt;p&gt;假设当前有两个进程正在运行 , 其状态就如下图所示 :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17181dfdc74873b8.webp&quot; alt=&quot;&quot; /&gt;
( 上图中我们也看出 , 实际物理内存并不是连续以及某个进程完整的 ) .&lt;/p&gt;

&lt;p&gt;映射表左侧的 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 代表当前地址有没有在物理内存中 . 为什么这么说呢 ?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;当应用被加载到内存中时 , 并不会将整个应用加载到内存中 . 只会放用到的那一部分 . 也就是懒加载的概念 , 换句话说就是应用使用多少 , 实际物理内存就实际存储多少 .&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;当应用访问到某个地址 , 映射表中为 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; , 也就是说并没有被加载到物理内存中时 , 系统就会立刻阻塞整个进程 , 触发一个我们所熟知的 &lt;a href=&quot;https://baike.baidu.com/item/%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD/5029040?fr=aladdin&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;缺页中断 - Page Fault&lt;/code&gt;&lt;/a&gt; .&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;当一个缺页中断被触发 , 操作系统会从磁盘中重新读取这页数据到物理内存上 , 然后将映射表中虚拟内存指向对应 ( 如果当前内存已满 , 操作系统会通过置换页算法 &lt;strong&gt;找一页数据进行覆盖&lt;/strong&gt; , 这也是为什么开再多的应用也不会崩掉 , 但是之前开的应用再打开时 , 就重新启动了的根本原因 ).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过这种分页和覆盖机制 , 就完美的解决了内存浪费和效率问题 .&lt;/p&gt;

&lt;p&gt;但是此时 , 又出现了一个问题 .&lt;/p&gt;

&lt;p&gt;问 : 当应用开发完成以后由于采用了虚拟内存 , 那么其中一个函数无论如何运行 , 运行多少次 , 都会是虚拟内存中的固定地址 .&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么意思呢 ?&lt;/p&gt;

  &lt;p&gt;假设应用有一个函数 , 基于首地址偏移量为 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00a000&lt;/code&gt; , 那么虚拟地址从 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x000000 ~ 0xffffff&lt;/code&gt; , 基于这个 , 那么这个函数我无论如何只需要通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x00a000&lt;/code&gt; 这个虚拟地址就可以拿到其真实实现地址 .&lt;/p&gt;

  &lt;p&gt;而这种机制就给了很多黑客可操作性的空间 , 他们可以很轻易的提前写好程序获取固定函数的实现进行修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 操作 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了解决这个问题 , &lt;a href=&quot;https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%8A%A0%E8%BD%BD?fromtitle=aslr&amp;amp;fromid=5779647&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ASLR&lt;/code&gt;&lt;/a&gt; 应运而生 . 其原理就是 &lt;strong&gt;每次&lt;/strong&gt; 虚拟地址在映射真实地址之前 , 增加一个随机偏移值 , 以此来解决我们刚刚所提到的这个问题 .&lt;/p&gt;

&lt;p&gt;( &lt;code class=&quot;highlighter-rouge&quot;&gt;Android 4.0&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;Apple iOS4.3&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;OS X Mountain Lion10.8&lt;/code&gt; 开始全民引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;ASLR&lt;/code&gt; 技术 , 而实际上自从引入 &lt;code class=&quot;highlighter-rouge&quot;&gt;ASLR&lt;/code&gt; 后 , 黑客的门槛也自此被拉高 . 不再是人人都可做黑客的年代了 ) .&lt;/p&gt;

&lt;p&gt;至此 , 有关物理内存 , 虚拟内存 , 内存分页的完整流程和原理 , 我们已经讲述完毕了 , 那么接下来来到重点 , 二进制重排 .&lt;/p&gt;

&lt;h2 id=&quot;二进制重排&quot;&gt;二进制重排&lt;/h2&gt;

&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;

&lt;p&gt;在了解了内存分页会触发中断异常 &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Fault&lt;/code&gt; 会阻塞进程后 , 我们就知道了这个问题是会对性能产生影响的 .&lt;/p&gt;

&lt;p&gt;实际上在 &lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt; 系统中 , 对于生产环境的应用 , 当产生缺页中断进行重新加载时 , &lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt; 系统还会对其做一次签名验证 . 因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt; 生产环境的应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; 所产生的耗时要更多 .&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;抖音团队分享的一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Page Fault&lt;/code&gt;，开销在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.6 ~ 0.8ms&lt;/code&gt; , 实际测试发现不同页会有所不同 , 也跟 &lt;code class=&quot;highlighter-rouge&quot;&gt;cpu&lt;/code&gt; 负荷状态有关 , 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.1 ~ 1.0 ms&lt;/code&gt; 之间 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当用户使用应用时 , 第一个直接印象就是启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt; 耗时 , 而恰巧由于启动时期有大量的类 , 分类 , 三方 等等需要加载和执行 , 多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; 所产生的的耗时往往是不能小觑的 . 这也是二进制重排进行启动优化的必要性 .&lt;/p&gt;

&lt;h3 id=&quot;二进制重排优化原理&quot;&gt;二进制重排优化原理&lt;/h3&gt;

&lt;p&gt;假设在启动时期我们需要调用两个函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;method1&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;method4&lt;/code&gt; . 函数编译在 &lt;code class=&quot;highlighter-rouge&quot;&gt;mach-o&lt;/code&gt; 中的位置是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt; ( &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt; 的链接器) 的编译顺序并非调用顺序来的 . 因此很可能这两个函数分布在不同的内存页上 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171823985c7f3bc8.webp&quot; alt=&quot;&quot; /&gt;
那么启动时 , &lt;code class=&quot;highlighter-rouge&quot;&gt;page1&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;page2&lt;/code&gt; 则都需要从无到有加载到物理内存中 , 从而触发两次 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;而二进制重排的做法就是将 &lt;code class=&quot;highlighter-rouge&quot;&gt;method1&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;method4&lt;/code&gt; 放到一个内存页中 , 那么启动时则只需要加载 &lt;code class=&quot;highlighter-rouge&quot;&gt;page1&lt;/code&gt; 即可 , 也就是只触发一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; , 达到优化目的 .&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实际项目中的做法是将启动时需要调用的函数放到一起 ( 比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;前10页&lt;/code&gt;中 ) 以尽可能减少 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; , 达到优化目的&lt;/strong&gt;. 而这个做法就叫做 : &lt;code class=&quot;highlighter-rouge&quot;&gt;二进制重排&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;讲到这里相信很多同学已经迫不及待的想要看看具体怎么二进制重排了 . 其实操作很简单 , 但是在操作之前我们还需要知道这几点 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;如何检测 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; : 首先我们要想看到优化效果 , 就应该知道如何查看 page fault , 以此来帮助我们查看优化前以及优化后的效果 .&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;如何重排二进制 .&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;如何查看自己重排成功了没有 ?&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;如何检测自己启动时刻需要调用的所有方法 .&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hook objc_MsgSend&lt;/code&gt; ( 只能拿到 &lt;code class=&quot;highlighter-rouge&quot;&gt;oc&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; 加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;@objc dynamic&lt;/code&gt; 修饰后的方法 ) .&lt;/li&gt;
    &lt;li&gt;静态扫描 &lt;code class=&quot;highlighter-rouge&quot;&gt;macho&lt;/code&gt; 特定段和节里面所存储的符号以及函数数据 . (静态扫描 , 主要用来获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; 方法 , &lt;code class=&quot;highlighter-rouge&quot;&gt;c++ 构造&lt;/code&gt;(有关 c++ 构造 , 参考 &lt;a href=&quot;https://juejin.im/post/6844904040149729294&quot;&gt;从头梳理 dyld 加载流程&lt;/a&gt; 这篇文章有详细讲述和演示 ) .&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插桩 ( 完美版本 , 完全拿到 &lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;oc&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; 全部函数 )&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;内容很多 , 我们一项一项来 .&lt;/p&gt;

&lt;h3 id=&quot;如何查看-page-fault&quot;&gt;如何查看 page fault&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;提示 :&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果想查看真实 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; 次数 , 应该将应用卸载 , 查看第一次应用安装后的效果 , 或者先打开很多个其他应用 .&lt;/p&gt;

  &lt;p&gt;因为之前运行过 &lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt; , 应用其中一部分已经被加载到物理内存并做好映射表映射 , 这时再启动就会少触发一部分缺页中断 , 并且杀掉应用再打开也是如此 .&lt;/p&gt;

  &lt;p&gt;其实就是希望将物理内存中之前加载的覆盖/清理掉 , 减少误差 .&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;1️⃣ : 打开 Instruments , 选择 System Trace .
&lt;img src=&quot;/images/posts/iOS/optimize/171826390aca9ec8.webp&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;2️⃣ : 选择真机 , 选择工程 , 点击启动 , 当首个页面加载出来点击停止 . 这里注意 , 最好是将应用杀掉重新安装 , 因为冷热启动的界定其实由于进程的原因并不一定后台杀掉应用重新打开就是冷启动 .
&lt;img src=&quot;/images/posts/iOS/optimize/171826cb437d4038.webp&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;3️⃣ : 等待分析完成 , 查看缺页次数
      &lt;ul&gt;
        &lt;li&gt;后台杀掉重启应用
&lt;img src=&quot;/images/posts/iOS/optimize/1718278469553f07.webp&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;li&gt;第一次安装启动应用
&lt;img src=&quot;/images/posts/iOS/optimize/17185f8b44166292.webp&quot; alt=&quot;&quot; /&gt;
当然 , 你可以通过添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_PRINT_STATISTICS&lt;/code&gt; 来查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;pre-main&lt;/code&gt; 阶段总耗时来做一个侧面辅证 .&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;大家可以分别测试以下几种情况 , 来深度理解冷启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; 热启动以及物理内存分页覆盖的实际情况 .&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;应用第一次安装启动&lt;/li&gt;
  &lt;li&gt;应用后台没有打开时启动&lt;/li&gt;
  &lt;li&gt;杀掉后台后重新启动&lt;/li&gt;
  &lt;li&gt;不杀掉后台重新启动&lt;/li&gt;
  &lt;li&gt;杀掉后台后多打开一些其他应用再次启动&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二进制重排具体如何操作&quot;&gt;二进制重排具体如何操作&lt;/h3&gt;

&lt;p&gt;说了这么多前导知识 , 终于要开始做二进制重排了 , 其实具体操作很简单 , &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt; 已经提供好这个机制 , 并且 &lt;code class=&quot;highlighter-rouge&quot;&gt;libobjc&lt;/code&gt; 实际上也是用了二进制重排进行优化 .&lt;/p&gt;

&lt;p&gt;参考下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171831e4bf9052fc.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先 , &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt; 是用的链接器叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt; 有一个参数叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;Order File&lt;/code&gt; , 我们可以通过这个参数配置一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;order&lt;/code&gt; 文件的路径 .&lt;/li&gt;
  &lt;li&gt;在这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;order&lt;/code&gt; 文件中 , 将你需要的符号按顺序写在里面 .&lt;/li&gt;
  &lt;li&gt;当工程 &lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt; 的时候 , &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt; 会读取这个文件 , 打的二进制包就会按照这个文件中的符号顺序进行生成对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mach-O&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171881912d486b43.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;二进制重排疑问---题外话-&quot;&gt;二进制重排疑问 - 题外话 :&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;1️⃣ : &lt;code class=&quot;highlighter-rouge&quot;&gt;order&lt;/code&gt; 文件里 符号写错了或者这个符号不存在会不会有问题 ?&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;答 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt; 会忽略这些符号 , 实际上如果提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;link&lt;/code&gt; 选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;-order_file_statistics&lt;/code&gt;，会以 &lt;code class=&quot;highlighter-rouge&quot;&gt;warning&lt;/code&gt; 的形式把这些没找到的符号打印在日志里。 .&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;2️⃣ : 有部分同学可能会考虑这种方式会不会影响上架 ?&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;答 : 首先 , &lt;code class=&quot;highlighter-rouge&quot;&gt;objc&lt;/code&gt; 源码自己也在用这种方式 .&lt;/li&gt;
    &lt;li&gt;二进制重排只是重新排列了所生成的 &lt;code class=&quot;highlighter-rouge&quot;&gt;macho&lt;/code&gt; 中函数表与符号表的顺序 .&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;如何查看自己工程的符号顺序&quot;&gt;如何查看自己工程的符号顺序&lt;/h3&gt;

&lt;p&gt;重排前后我们需要查看自己的符号顺序有没有修改成功 , 这时候就用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;Link Map&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Link Map&lt;/code&gt; 是编译期间产生的产物 , ( ld 的读取二进制文件顺序默认是按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compile Sources&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;GUI&lt;/code&gt; 里的顺序 ) , 它记录了二进制文件的布局 . 通过设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;Write Link Map File&lt;/code&gt; 来设置输出与否 , 默认是 &lt;code class=&quot;highlighter-rouge&quot;&gt;no&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171834c80dfceea3.webp&quot; alt=&quot;&quot; /&gt;
修改完毕后 &lt;code class=&quot;highlighter-rouge&quot;&gt;clean&lt;/code&gt; 一下 , 运行工程 , &lt;code class=&quot;highlighter-rouge&quot;&gt;Products&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;show in finder&lt;/code&gt;, 找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;macho&lt;/code&gt; 的上上层目录.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171835a71be25590.webp&quot; alt=&quot;&quot; /&gt;
按下图依次找到最新的一个 .txt 文件并打开.
&lt;img src=&quot;/images/posts/iOS/optimize/171835c7f1f3709b.webp&quot; alt=&quot;&quot; /&gt;
这个文件中就存储了所有符号的顺序 , 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;# Symbols:&lt;/code&gt; 部分 ( 前面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt; 等内容忽略 , 这部分在笔者后续讲述 &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm&lt;/code&gt; 编译器篇章会详细讲解 ) .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171835fc4977d819.webp&quot; alt=&quot;&quot; /&gt;
可以看到 , 这个符号顺序明显是按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compile Sources&lt;/code&gt; 的文件顺序来排列的 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/1718365d7afc7248.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;提示-&quot;&gt;提示 :&lt;/h4&gt;

&lt;p&gt;上述文件中最左侧地址就是 &lt;strong&gt;实际代码地址而并非符号地址&lt;/strong&gt; , &lt;strong&gt;因此我们二进制重排并非只是修改符号地址 , 而是利用符号顺序 , 重新排列整个代码在文件的偏移地址 , 将启动需要加载的方法地址放到前面内存页中 , 以此达到减少 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; 的次数从而实现时间上的优化&lt;/strong&gt; , 一定要清楚这一点 .&lt;/p&gt;

&lt;p&gt;你可以利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;MachOView&lt;/code&gt; 查看排列前后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_text&lt;/code&gt; 段 ( 代码段 ) 中的源码顺序来帮助理解 .&lt;/p&gt;

&lt;h3 id=&quot;实战演练&quot;&gt;实战演练&lt;/h3&gt;

&lt;p&gt;来到工程根目录 , 新建一个文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;touch lb.order&lt;/code&gt; . 随便挑选几个启动时就需要加载的方法 , 例如我这里选了以下几个 .&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-[LBOCTools lbCurrentPresentingVC]
+[LBOCTools lbGetCurrentTimes]
+[RSAEncryptor stripPublicKeyHeader:]
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写到该文件中 , 保存 , 配置文件路径 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171837e1db3da1b2.webp&quot; alt=&quot;&quot; /&gt;
重新运行 , 查看 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/1718384f9679b381.webp&quot; alt=&quot;&quot; /&gt;
可以看到 , 我们所写的这三个方法已经被放到最前面了 , 至此 , 生成的 &lt;code class=&quot;highlighter-rouge&quot;&gt;macho&lt;/code&gt; 中距离首地址偏移量最小的代码就是我们所写的这三个方法 , 假设这三个方法原本在不同的三页 , 那么我们就已经优化掉了两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;错误提示&quot;&gt;错误提示&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;有部分同学可能配置完运行会发现报错说&lt;code class=&quot;highlighter-rouge&quot;&gt;can't open&lt;/code&gt; 这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;order file&lt;/code&gt; . 是因为文件格式的问题 . 不用使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;mac&lt;/code&gt; 自带的文本编辑 . 使用命令工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;touch&lt;/code&gt; 创建即可 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;获取启动加载所有函数的符号&quot;&gt;获取启动加载所有函数的符号&lt;/h2&gt;

&lt;p&gt;讲到这 , 我们就只差一个问题了 , 那就是如何知道我的项目启动需要调用哪些方法 , 上述篇章中我们也有稍微提到一点 .&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hook objc_MsgSend&lt;/code&gt; ( 只能拿到 &lt;code class=&quot;highlighter-rouge&quot;&gt;oc&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;@objc dynamic&lt;/code&gt; 后的方法 , 并且由于可变参数个数 , 需要用汇编来获取参数 .)&lt;/li&gt;
    &lt;li&gt;静态扫描 &lt;code class=&quot;highlighter-rouge&quot;&gt;macho&lt;/code&gt; 特定段和节里面所存储的符号以及函数数据 . (静态扫描 , 主要用来获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; 方法 , &lt;code class=&quot;highlighter-rouge&quot;&gt;c++ 构造&lt;/code&gt;(有关 c++ 构造 , 参考 &lt;a href=&quot;https://juejin.im/post/6844904040149729294&quot;&gt;从头梳理 dyld 加载流程&lt;/a&gt; 这篇文章有详细讲述和演示 ) .&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插桩 ( 完美版本 , 完全拿到 &lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;oc&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; 全部函数 ) .&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;前两种这里我们就不在赘述了 . 网上参考资料也较多 , 而且实现效果也并不是完美状态 , 本文我们来谈谈如何通过编译期插桩的方式来 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 获取所有的函数符号 .&lt;/p&gt;

&lt;h2 id=&quot;clang-插桩&quot;&gt;clang 插桩&lt;/h2&gt;

&lt;p&gt;关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 的插桩覆盖的官方文档如下 : &lt;a href=&quot;http://clang.llvm.org/docs/SanitizerCoverage.html&quot;&gt;clang 自带代码覆盖工具&lt;/a&gt;文档中有详细概述 , 以及简短 &lt;code class=&quot;highlighter-rouge&quot;&gt;Demo&lt;/code&gt; 演示 .&lt;/p&gt;

&lt;h3 id=&quot;思考&quot;&gt;思考&lt;/h3&gt;

&lt;p&gt;其实 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插桩主要有两个实现思路 , 一是自己编写 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插件 ( 自定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插件在后续底层篇 &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm&lt;/code&gt; 中会带着大家来手写一个自己的插件 ) , 另外一个就是利用 clang 本身已经提供的一个工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; 机制来实现我们获取所有符号的需求 . 本文我们就按照第二种思路来实际演练一下 .&lt;/p&gt;

&lt;h3 id=&quot;原理探索&quot;&gt;原理探索&lt;/h3&gt;

&lt;p&gt;新建一个工程来测试和使用一下这个静态插桩代码覆盖工具的机制和原理 . ( 不想看这个过程的自行跳到静态插桩原理总结章节 )&lt;/p&gt;

&lt;p&gt;按照文档指示来走 .&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先 , 添加编译设置 .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接搜索 &lt;code class=&quot;highlighter-rouge&quot;&gt;Other C Flags&lt;/code&gt; 来到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Apple Clang - Custom Compiler Flags&lt;/code&gt; 中 , 添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-fsanitize-coverage=trace-pc-guard
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 代码 .&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,
                                                    uint32_t *stop) {
  static uint64_t N; // Counter for the guards.
  if (start == stop || *start) return; // Initialize only once.
  printf(&quot;INIT: %p %p\n&quot;, start, stop);
  for (uint32_t *x = start; x &amp;lt; stop; x++)
    *x = ++N; // Guards should start from 1.
}

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
  if (!*guard) return; // Duplicate the guard check.

  void *PC = __builtin_return_address(0);
  char PcDescr[1024];
  //__sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);
}
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;笔者这里是写在空工程的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewController.m&lt;/code&gt; 里的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17186308fe437f30.webp&quot; alt=&quot;&quot; /&gt;
代码命名 &lt;code class=&quot;highlighter-rouge&quot;&gt;INIT&lt;/code&gt; 后面打印的两个指针地址叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt; . 那么我们通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt; 来查看下从 &lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt; 这个内存地址里面所存储的到底是啥 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17186339ca5b17f2.webp&quot; alt=&quot;&quot; /&gt;
发现存储的是从 &lt;strong&gt;1&lt;/strong&gt; 到 &lt;strong&gt;14&lt;/strong&gt; 这个序号 . 那么我们来添加一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;oc&lt;/code&gt; 方法 .&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)testOCFunc{
    
}
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再次运行查看 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/1718637b18b59fb1.webp&quot; alt=&quot;&quot; /&gt;
发现从 &lt;code class=&quot;highlighter-rouge&quot;&gt;0e&lt;/code&gt; 变成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;0f&lt;/code&gt; . 也就是说存储的 1 到 14 这个序号变成了 1 到 15 .&lt;/p&gt;

&lt;p&gt;那么我们再添加一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 函数 , 一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; , 和一个触摸屏幕方法来看下 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171868f0c8146022.webp&quot; alt=&quot;&quot; /&gt;
同样发现序号依次增加到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;18&lt;/code&gt; 个 , 那么我们得到一个猜想 , 这个内存区间保存的就是工程所有符号的个数 .&lt;/p&gt;

&lt;p&gt;其次 , 我们在触摸屏幕方法调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 函数 , &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 函数中调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; . 那么我们点击屏幕 , 发现如下 :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171868fda686fd0d.webp&quot; alt=&quot;&quot; /&gt;
发现我们实际调用几个方法 , 就会打印几次 &lt;code class=&quot;highlighter-rouge&quot;&gt;guard :&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;实际上就类似我们埋点统计所实现的效果 . 在触摸方法添加一个断点查看汇编 :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/1718693991f87419.webp&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/images/posts/iOS/optimize/1718694aa700d3e3.webp&quot; alt=&quot;&quot; /&gt;
通过汇编我们发现 , &lt;strong&gt;在每个函数调用的第一句实际代码 ( 栈平衡与寄存器数据准备除外 ) , 被添加进去了一个 bl 调用到 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 这个函数中来&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而实际上这也是静态插桩的原理和名称由来 .&lt;/p&gt;

&lt;h3 id=&quot;静态插桩总结&quot;&gt;静态插桩总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;静态插桩实际上是在编译期就在每一个函数内部二进制源数据添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 代码 ( 我们添加的 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 函数 ) 来实现全局的方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 的效果 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;疑问&quot;&gt;疑问&lt;/h3&gt;

&lt;p&gt;可能有部分同学对我上述表述的原理总结有些疑问 .&lt;/p&gt;

&lt;p&gt;究竟是直接修改二进制在每个函数内部都添加了调用 hook 函数这个汇编代码 , 还是只是类似于编译器在所生成的二进制文件添加了一个标记 , 然后在运行时如果有这个标记就会自动多做一步调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 代码呢 ?&lt;/p&gt;

&lt;p&gt;笔者这里使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;hopper&lt;/code&gt; 来看下生成的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mach-o&lt;/code&gt; 二进制文件 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17186a02c7b5eeff.webp&quot; alt=&quot;&quot; /&gt;
上述二进制源文件我们就发现 , 的确是函数内部 一开始就添加了 调用额外方法的汇编代码 . 这也是我们为什么称其为 &lt;strong&gt;” 静态插桩 “&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;讲到这里 , 原理我们大体上了解了 , 那么到底如何才能拿到函数的符号呢 ?&lt;/p&gt;

&lt;h3 id=&quot;获取所有函数符号&quot;&gt;获取所有函数符号&lt;/h3&gt;

&lt;p&gt;先理一下思路 .&lt;/p&gt;

&lt;h4 id=&quot;思路&quot;&gt;思路&lt;/h4&gt;

&lt;p&gt;我们现在知道了 , 所有函数内部第一步都会去调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 这个函数 . 那么熟悉汇编的同学可能就有这么个想法 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数嵌套时 , 在跳转子函数时都会保存下一条指令的地址在 &lt;code class=&quot;highlighter-rouge&quot;&gt;X30&lt;/code&gt; ( 又叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;lr&lt;/code&gt; 寄存器) 里 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如 , &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; 函数中调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 函数 , 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;arm&lt;/code&gt; 汇编中即 &lt;code class=&quot;highlighter-rouge&quot;&gt;bl + 0x **** &lt;/code&gt; 指令 , 该指令会首先将下一条汇编指令的地址保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;x30&lt;/code&gt; 寄存器中 ,&lt;br /&gt;
然后在跳转到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bl&lt;/code&gt; 后面传递的指定地址去执行 . ( 提示 : &lt;code class=&quot;highlighter-rouge&quot;&gt;bl&lt;/code&gt; 能实现跳转到某个地址的汇编指令 , 其原理就是修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;pc&lt;/code&gt; 寄存器的值来指向到要跳转的地址 , 而且实际上 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 函数中也会对 &lt;code class=&quot;highlighter-rouge&quot;&gt;x29 / x30&lt;/code&gt; 寄存器的值做保护防止子函数又跳转其他函数会覆盖掉 &lt;code class=&quot;highlighter-rouge&quot;&gt;x30&lt;/code&gt; 的值 , 当然 , 叶子函数除外 . ) .&lt;/p&gt;

&lt;p&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 函数执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; 也就是返回指令时 , 就会去读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;x30&lt;/code&gt; 寄存器的地址 , 跳转过去 , 因此也就回到了上一层函数的下一步 .&lt;/p&gt;

&lt;p&gt;这种思路来实现实际上是可以的 . 我们所写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 函数中的这一句代码 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void *PC = __builtin_return_address(0); 
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的作用其实就是去读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;x30&lt;/code&gt; 中所存储的要返回时下一条指令的地址 . 所以他名称叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;__builtin_return_address&lt;/code&gt; . 换句话说 , 这个地址就是我当前这个函数执行完毕后 , 要返回到哪里去 .&lt;/p&gt;

&lt;p&gt;其实 , &lt;code class=&quot;highlighter-rouge&quot;&gt;bt&lt;/code&gt; 函数调用栈也是这种思路来实现的 .&lt;/p&gt;

&lt;p&gt;也就是说 , &lt;strong&gt;我们现在可以在 ` __sanitizer_cov_trace_pc_guard&lt;code class=&quot;highlighter-rouge&quot;&gt; 这个函数中 , 通过 &lt;/code&gt;__ builtin_return_address&lt;code class=&quot;highlighter-rouge&quot;&gt; 数拿到原函数调用 &lt;/code&gt;__sanitizer_cov_trace_pc_guard` 这句汇编代码的下一条指令的地址&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;可能有点绕 , 画个图来梳理一下流程 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171872a841e4a676.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据内存地址获取函数名称&quot;&gt;根据内存地址获取函数名称&lt;/h4&gt;

&lt;p&gt;拿到了函数内部一行代码的地址 , 如何获取函数名称呢 ? 这里笔者分享一下自己的思路 .&lt;/p&gt;

&lt;p&gt;熟悉安全攻防 , 逆向的同学可能会清楚 . 我们为了防止某些特定的方法被别人使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;fishhook&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 掉 , 会利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dlopen&lt;/code&gt; 打开动态库 , 拿到一个句柄 , 进而拿到函数的内存地址直接调用 .&lt;/p&gt;

&lt;p&gt;是不是跟我们这个流程有点相似 , 只是我们好像是反过来的 . 其实反过来也是可以的 .&lt;/p&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;dlopen&lt;/code&gt; 相同 , 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;dlfcn.h&lt;/code&gt; 中有一个方法如下 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct dl_info {
        const char *dli_fname; /* 所在文件 */
        void *dli_fbase; /* 文件地址 */
        const char *dli_sname; /* 符号名称 */
        void *dli_saddr; /* 函数起始地址 */
} Dl_info;

//这个函数能通过函数内部地址找到函数符号
int dladdr(const void *, Dl_info *);
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;紧接着我们来实验一下 , 先导入头文件&lt;code class=&quot;highlighter-rouge&quot;&gt;#import &amp;lt;dlfcn.h&amp;gt;&lt;/code&gt; , 然后修改代码如下 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
    if (!*guard) return; // Duplicate the guard check.
    
    void *PC = __builtin_return_address(0);
    Dl_info info;
    dladdr(PC, &amp;amp;info);
    
    printf(&quot;fname=%s \nfbase=%p \nsname=%s\nsaddr=%p \n&quot;,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);
    
    char PcDescr[1024];
    printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);
}
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查看打印结果 :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171873d06b5bfd62.webp&quot; alt=&quot;&quot; /&gt;
终于看到我们要找的符号了 .&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;收集符号&quot;&gt;收集符号&lt;/h3&gt;

&lt;p&gt;看到这里 , 很多同学可能想的是 , 那马上到工程里去拿到我所有的符号 , 写到 &lt;code class=&quot;highlighter-rouge&quot;&gt;order&lt;/code&gt; 文件里不就完事了吗 ?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17187432df608495.webp&quot; alt=&quot;&quot; /&gt;
为什么呢 ??&lt;/p&gt;

&lt;h3 id=&quot;clang静态插桩---坑点1&quot;&gt;clang静态插桩 - 坑点1&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;→ : 多线程问题&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一个多线程的问题 , 由于你的项目各个方法肯定有可能会在不同的函数执行 , 因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 这个函数也有可能受多线程影响 , 所以你当然不可能简简单单用一个数组来接收所有的符号就搞定了 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那方法有很多 , 笔者在这里分享一下自己的做法 :&lt;/p&gt;

&lt;p&gt;考虑到这个方法会来特别多次 , 使用锁会影响性能 , 这里使用苹果底层的原子队列 ( 底层实际上是个栈结构 , 利用队列结构 + 原子性来保证顺序 ) 来实现 .&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event{
    //遍历出队
    while (true) {
        //offsetof 就是针对某个结构体找到某个属性相对这个结构体的偏移量
        SymbolNode * node = OSAtomicDequeue(&amp;amp;symboList, offsetof(SymbolNode, next));
        if (node == NULL) break;
        Dl_info info;
        dladdr(node-&amp;gt;pc, &amp;amp;info);
        
        printf(&quot;%s \n&quot;,info.dli_sname);
    }
}
//原子队列
static OSQueueHead symboList = OS_ATOMIC_QUEUE_INIT;
//定义符号结构体
typedef struct{
    void * pc;
    void * next;
}SymbolNode;

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
    if (!*guard) return; // Duplicate the guard check.
    void *PC = __builtin_return_address(0);
    SymbolNode * node = malloc(sizeof(SymbolNode));
    *node = (SymbolNode){PC,NULL};
    
    //入队
    // offsetof 用在这里是为了入队添加下一个节点找到 前一个节点next指针的位置
    OSAtomicEnqueue(&amp;amp;symboList, node, offsetof(SymbolNode, next));
}
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当你兴致冲冲开始考虑好多线程的解决方法写完之后 , 运行发现 :&lt;/p&gt;

&lt;p&gt;死循环了 .&lt;/p&gt;

&lt;h3 id=&quot;clang静态插桩---坑点2&quot;&gt;clang静态插桩 - 坑点2&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;→ : 上述这种 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插桩的方式 , 会在循环中同样插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 代码&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;当确定了我们队列入队和出队都是没问题的 , 你自己的写法对应的保存和读取也是没问题的 , 我们发现了这个坑点 , 这个会死循环 , 为什么呢 ?&lt;/p&gt;

&lt;p&gt;这里我就不带着大家去分析汇编了 , 直接说结论 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过汇编会查看到 一个带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; 循环的方法 , 会被静态加入多次 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 调用 , 导致死循环.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;→ : 解决方案&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Other C Flags&lt;/code&gt; 修改为如下 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-fsanitize-coverage=func,trace-pc-guard
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代表进针对 &lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt; 进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; . 再次运行 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171877672af5a92d.webp&quot; alt=&quot;&quot; /&gt;
又以为完事了 ? 还没有..&lt;/p&gt;

&lt;h3 id=&quot;坑点3--load-方法&quot;&gt;坑点3 : load 方法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;→ : &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; 方法时 , &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 函数的参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;guard&lt;/code&gt; 是 0&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;上述打印并没有发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;解决 : 屏蔽掉 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 函数中的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (!*guard) return;
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171877cd4dca5b6b.webp&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; 方法就有了 .&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里也为我们提供了一点启示:&lt;/p&gt;

  &lt;p&gt;如果我们希望从某个函数之后/之前开始优化 , 通过一个全局静态变量 , 在特定的时机修改其值 , 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;__sanitizer_cov_trace_pc_guard&lt;/code&gt; 这个函数中做好对应的处理即可 .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;剩余细化工作&quot;&gt;剩余细化工作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果你也是使用笔者这种多线程处理方式的话 , 由于用的先进后出原因 , 我们要倒叙一下&lt;/li&gt;
  &lt;li&gt;还需要做去重 .&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;order&lt;/code&gt; 文件格式要求 &lt;strong&gt;c&lt;/strong&gt; 函数 , &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; 调用前面还需要加 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; , 下划线 .&lt;/li&gt;
  &lt;li&gt;写入文件即可 .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;笔者 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo&lt;/code&gt; 完整代码如下 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;ViewController.h&quot;
#import &amp;lt;dlfcn.h&amp;gt;
#import &amp;lt;libkern/OSAtomic.h&amp;gt;
@interface ViewController ()
@end

@implementation ViewController
+ (void)load{
    
}
- (void)viewDidLoad {
    [super viewDidLoad];
    testCFunc();
    [self testOCFunc];
}
- (void)testOCFunc{
    NSLog(@&quot;oc函数&quot;);
}
void testCFunc(){
    LBBlock();
}
void(^LBBlock)(void) = ^(void){
    NSLog(@&quot;block&quot;);
};

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,
                                         uint32_t *stop) {
    static uint64_t N; // Counter for the guards.
    if (start == stop || *start) return; // Initialize only once.
    printf(&quot;INIT: %p %p\n&quot;, start, stop);
    for (uint32_t *x = start; x &amp;lt; stop; x++)
        *x = ++N; // Guards should start from 1.
}
- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event{
    NSMutableArray&amp;lt;NSString *&amp;gt; * symbolNames = [NSMutableArray array];
    while (true) {
        //offsetof 就是针对某个结构体找到某个属性相对这个结构体的偏移量
        SymbolNode * node = OSAtomicDequeue(&amp;amp;symboList, offsetof(SymbolNode, next));
        if (node == NULL) break;
        Dl_info info;
        dladdr(node-&amp;gt;pc, &amp;amp;info);
        
        NSString * name = @(info.dli_sname);
        
        // 添加 _
        BOOL isObjc = [name hasPrefix:@&quot;+[&quot;] || [name hasPrefix:@&quot;-[&quot;];
        NSString * symbolName = isObjc ? name : [@&quot;_&quot; stringByAppendingString:name];
        
        //去重
        if (![symbolNames containsObject:symbolName]) {
            [symbolNames addObject:symbolName];
        }
    }

    //取反
    NSArray * symbolAry = [[symbolNames reverseObjectEnumerator] allObjects];
    NSLog(@&quot;%@&quot;,symbolAry);
    
    //将结果写入到文件
    NSString * funcString = [symbolAry componentsJoinedByString:@&quot;\n&quot;];
    NSString * filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;lb.order&quot;];
    NSData * fileContents = [funcString dataUsingEncoding:NSUTF8StringEncoding];
    BOOL result = [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];
    if (result) {
        NSLog(@&quot;%@&quot;,filePath);
    }else{
        NSLog(@&quot;文件写入出错&quot;);
    }
    
}
//原子队列
static OSQueueHead symboList = OS_ATOMIC_QUEUE_INIT;
//定义符号结构体
typedef struct{
    void * pc;
    void * next;
}SymbolNode;

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
    //if (!*guard) return; // Duplicate the guard check.
    
    void *PC = __builtin_return_address(0);
    
    SymbolNode * node = malloc(sizeof(SymbolNode));
    *node = (SymbolNode){PC,NULL};
    
    //入队
    // offsetof 用在这里是为了入队添加下一个节点找到 前一个节点next指针的位置
    OSAtomicEnqueue(&amp;amp;symboList, node, offsetof(SymbolNode, next));
}
@end
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;文件写入到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmp&lt;/code&gt; 路径下 , 运行 , 打开手机下载查看 :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17187982a312a97d.webp&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/images/posts/iOS/optimize/171879959d85dbe6.webp&quot; alt=&quot;&quot; /&gt;
搞定 , 小伙伴们就可以立马去优化自己的工程了 .&lt;/p&gt;

&lt;h2 id=&quot;swift-工程--混编工程问题&quot;&gt;swift 工程 / 混编工程问题&lt;/h2&gt;

&lt;p&gt;通过如上方式适合纯 &lt;code class=&quot;highlighter-rouge&quot;&gt;OC&lt;/code&gt; 工程获取符号方式 .&lt;/p&gt;

&lt;p&gt;由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; 的编译器前端是自己的 &lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; 编译前端程序 , 因此配置稍有不同 .&lt;/p&gt;

&lt;p&gt;搜索 &lt;code class=&quot;highlighter-rouge&quot;&gt;Other Swift Flags&lt;/code&gt; , 添加两条配置即可 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-sanitize-coverage=func&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-sanitize=undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swift&lt;/code&gt; 类通过上述方法同样可以获取符号 .&lt;/p&gt;

&lt;h2 id=&quot;cocoapod-工程问题&quot;&gt;cocoapod 工程问题&lt;/h2&gt;

&lt;p&gt;对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;cocoapod&lt;/code&gt; 工程引入的库 , 由于针对不同的 &lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt; . 那么我们在主程序中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt; 添加的编译设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;Write Link Map File&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;-fsanitize-coverage=func,trace-pc-guard&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;order file&lt;/code&gt; 等设置肯定是不会生效的 . 解决方法就是针对需要的 &lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt; 去做对应的设置即可 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171c6046384cd6a3.webp&quot; alt=&quot;&quot; /&gt;
对于直接手动导入到工程里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;sdk&lt;/code&gt; , 不管是 &lt;code class=&quot;highlighter-rouge&quot;&gt;静态库 .a&lt;/code&gt; 还是 &lt;code class=&quot;highlighter-rouge&quot;&gt;动态库&lt;/code&gt; , 默认主工程的设置就可以了 , 是可以拿到符号的 .&lt;/p&gt;

&lt;p&gt;最后提示一下 , 手动导入的三方库如果没有导入并且使用的话 , 是不会加载的 . 添加了 &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; 方法也是如此 .&lt;/p&gt;

&lt;h2 id=&quot;部分同学反应的添加设置后报错问题&quot;&gt;部分同学反应的添加设置后报错问题&lt;/h2&gt;

&lt;p&gt;部分同学反应添加了 &lt;code class=&quot;highlighter-rouge&quot;&gt;-fsanitize-coverage=func,trace-pc-guard&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Other C Flags&lt;/code&gt; 时 , 直接编译工程会报错 .&lt;/p&gt;

&lt;p&gt;这个是由于没有跟着文章所讲完成导致的 . 添加了这个 flag 之后 , 需要实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 代码 , 否则编译会提示找不到这个符号 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/171c60b664bf6233.webp&quot; alt=&quot;&quot; /&gt;
根据本文 “&lt;code class=&quot;highlighter-rouge&quot;&gt;clang 插桩 -&amp;gt; 原理探索&lt;/code&gt;” 部分添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;hook&lt;/code&gt; 函数实现即可 . 或者可以直接使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;笔者 demo 完整代码&lt;/code&gt; .&lt;/p&gt;

&lt;h2 id=&quot;优化后效果监测&quot;&gt;优化后效果监测&lt;/h2&gt;

&lt;p&gt;在完全第一次安装冷启动 , 保证同样的环境 , &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; 采样同样截取到第一个可交互界面 , 使用重排优化前后效果如下 .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/posts/iOS/optimize/17185f8b44166292-1.webp&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/images/posts/iOS/optimize/171881e08c14e025.webp&quot; alt=&quot;&quot; /&gt;
实际上 , 在生产环境中 , 由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt; 还需要签名验证 , 因此在分发环境下 , 优化效果其实更多 .&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本篇文章通过以实际碳素过程为基准 , 一步一步实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 静态插桩达到二进制重排优化启动时间的完整流程 .&lt;/p&gt;

&lt;p&gt;具体实现步骤如下 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1️⃣ : 利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;clang&lt;/code&gt; 插桩获得启动时期需要加载的所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;函数/方法&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;swift 方法&lt;/code&gt;以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;c++构造方法&lt;/code&gt;的符号 .&lt;/li&gt;
  &lt;li&gt;2️⃣ : 通过 order file 机制实现二进制重排 .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904130406793224&quot;&gt;转自掘金&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如有疑问或者不同看法 , 欢迎留言交流 .&lt;/p&gt;

</description>
        <pubDate>Sat, 12 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/iOS%E4%BC%98%E5%8C%96%E7%AF%87-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E4%B9%8BClang%E6%8F%92%E6%A1%A9%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/iOS%E4%BC%98%E5%8C%96%E7%AF%87-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E4%B9%8BClang%E6%8F%92%E6%A1%A9%E5%AE%9E%E7%8E%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>博客模板功能介绍</title>
        <description>&lt;p&gt;这篇文章主要讲的是如何使用和修改我的博客主题，文章内容含以下几点：&lt;/p&gt;

&lt;h2 id=&quot;博客特性&quot;&gt;博客特性&lt;/h2&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;适配电脑、手机、平板等各屏幕&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;响应式设计&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;个性化头像&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;每篇文章自动添加打赏功能&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持Disqus、livere评论系统&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持站点总数访问统计，每篇文章访问统计&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持文章自动生成目录&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持标签分类&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持代码高亮&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持文章H1、H2、H3、H4标题样式多样化&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持多种三方社交icon展示，能从博客直接跳转到自己的三方社交主页&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;支持三方社交分享(facebook、twitter)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;博客主要模块介绍&quot;&gt;博客主要模块介绍&lt;/h2&gt;

&lt;h3 id=&quot;_configyml&quot;&gt;_config.yml&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 是博客的配置文件，整个站点的信息都在这修改，想要把我的模板改成你自己的也需要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要字段说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;enableToc: 是否开启文章自动生成目录，设置为false文章不会自动生成目录&lt;/li&gt;
  &lt;li&gt;comment/livere: livere评论系统，支持微信、qq、微博、豆瓣、twitter等登录后可以直接评论&lt;/li&gt;
  &lt;li&gt;comment/disqus: disqus评论系统，支持facebook、twitter等登录后可以直接评论&lt;/li&gt;
  &lt;li&gt;social/weibo、github、zhihu、jianshu等: 个人站底部展示的微博等三方社交按钮，点击后直接跳转到个人微博或其他社交主页&lt;/li&gt;
  &lt;li&gt;baidu/id: 百度统计，用来统计你个人站点的用户访问情况&lt;/li&gt;
  &lt;li&gt;ga/id: google统计，用来统计你个人站点的用户访问情况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;_config.yml 文件除以上字段还有一些可以自行修改，例如title之类的字段&lt;/p&gt;

&lt;h3 id=&quot;_posts&quot;&gt;_posts&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; 目录是用来存放文章的目录，写新文章，直接放在这个目录即可&lt;/p&gt;

&lt;p&gt;使用博客模板时，请把博客自带的文章给去掉，如果想使用博客自带的文章请 &lt;code class=&quot;highlighter-rouge&quot;&gt;注明出处&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;自定义页面&quot;&gt;自定义页面&lt;/h3&gt;

&lt;p&gt;about.md、support.md 等为自定义页面，如果你想添加自动以页面可以直接复制about.md 文件修改文件名和里面的内容即可。&lt;/p&gt;

&lt;p&gt;如果需要在导航显示你新增的页面，直接在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 文件的nav字段中添加你新页面配置即可&lt;/p&gt;

&lt;h3 id=&quot;修改说明&quot;&gt;修改说明&lt;/h3&gt;

&lt;p&gt;如果要修改博客模板信息建议只修改&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 文件内容和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; 里面的文章信息。因为博客模板一直在更新迭代，改动多了以免你后期更新博客模板的时候不方便。&lt;/p&gt;

&lt;p&gt;如果你想改动模板的样式又想继续更新迭代博客模板，你可以提交在github上提交&lt;code class=&quot;highlighter-rouge&quot;&gt;pull request&lt;/code&gt; 或者直接给我发邮件建议改成什么样，如果你的提议确实可以，我会采纳的，并且非常感谢你的建议。&lt;/p&gt;

</description>
        <pubDate>Sat, 11 Jul 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/07/blog_info/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/07/blog_info/</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
  </channel>
</rss>
